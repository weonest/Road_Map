# 네트워크 기초 이론3

## 25. TCP 송/수신 원리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84e99fde-ed94-4c00-8437-b45461b88ff1/Untitled.png)

- 어떤 PC와 서버가 TCP/IP 연결을 하여 File을 다운로드 한다는 가정

### Server측

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43639e33-2275-4917-81ce-5d224833ae0f/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26664b7a-68a2-4727-ac27-99390b548e4a/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dd263bd8-e501-4d55-b720-330154f863b8/Untitled.png)

- User mode에서 Server (Process) 가 가동 중. Socket (File) 이 열려 있음

- Process가 File에 대고 할 수 있는 작업은 기본적으로 `RWX` 가 있음

- Socket 통신에 실행 (`X`)가 있을리는 없으니 읽기, 쓰기. Socket 통신에서 Read = Receive, Write = Send. 즉, Server가 Socket에 `I/O`를 한다 (인바운드, 아웃바운드?)

- 파일 송수신에 **Memory (Buffer)**를 할당하게 돼있음

  - File의 크기가 1.4MB라고 가정
  - Memory는 File의 크기보다 작게 설정
    - 통째로 한 방에 읽는 것이 아니라 끊어서 읽음 (Read)
    - **비유** : 퍼즐 전체를 조각내서 가져와 Memory에 쌓임 / ***이 전체가 Stream 인가?***

- Scoket에서의 분해가 중요

  - 여기도 **Buffer**가 있을 수 있는데, Memory 에서의 데이터를 카피 → 이를 Buffered I/O
  - TCP가 이렇게 가지고 있다가 IP쪽으로 내려갈때, 이 데이터들을 잘게 쪼갠 것을 Segment
    - **비유 :** Memory에 쌓인 퍼즐 조각이 그대로 이곳의 Buffer로 옴
    - Segment로의 분해가 일어날 때 각 퍼즐 조각에 번호가 붙음

- 트럭 (Frame)의 목적지는 ?

  - 도착지 PC의 File에 연결된 File I/O Buffer가 있음
  - **TCP Buffer**도 있음
  - 트럭에서 박스를 빼면 트럭은 사라지고, Packet을 뜯으면 Segment가 나옴 (Decapsulation)
  - TCP Buffer의 크기를 **Window Size** (수신측에서 Segment가 날라오면 조립해서 집어넣는 공간)

- 수신측은 서버측에 데이터를 잘 수신했다고 통신을 보냄 = ACK (

  필요한 데이터의 번호 + Window size와 함께

  )

  - 서버는 데이터를 잘 보내고 Wait을 함. ACK+데이터번호 를 기다림
    - 이 과정 때문에 속도 지연 발생
  - 수신측의 ACK에서 보내온 Window size에 서버측의 데이터가 들어갈 **공간이 없다면 데이저 송신을 중지**! = **Wait이 걸림**

- 송수신 시간을 단축하기 위해서는 수신측의 

  Receive 속도가 중요함

  - TCP Buffer에서 File I/O Buffer로 파일을 빨리 올려야 함
  - Read (Process 가 Socket을 읽는 것) 속도가 Network에서 수신(Segment가 TCP Buffer에 쌓이는 것)하는 속도 보다 빨랴아함. 느리면 Window size가 점점 좁아짐
  - 이러한 문제가 발생하면 Network에서 원인을 찾는 것이 아니라 Process에서 찾아야 한다