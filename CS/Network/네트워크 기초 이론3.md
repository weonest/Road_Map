- - # 네트워크 기초 이론3

    ## 25. TCP 송/수신 원리

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84e99fde-ed94-4c00-8437-b45461b88ff1/Untitled.png)
  
    - 어떤 PC와 서버가 TCP/IP 연결을 하여 File을 다운로드 한다는 가정
  
    ### Server측
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43639e33-2275-4917-81ce-5d224833ae0f/Untitled.png)
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26664b7a-68a2-4727-ac27-99390b548e4a/Untitled.png)
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dd263bd8-e501-4d55-b720-330154f863b8/Untitled.png)
  
    - User mode에서 Server (Process) 가 가동 중. Socket (File) 이 열려 있음
  
    - Process가 File에 대고 할 수 있는 작업은 기본적으로 `RWX` 가 있음
  
    - Socket 통신에 실행 (`X`)가 있을리는 없으니 읽기, 쓰기. Socket 통신에서 Read = Receive, Write = Send. 즉, Server가 Socket에 `I/O`를 한다 (인바운드, 아웃바운드?)
  
    - 파일 송수신에 **Memory (Buffer)**를 할당하게 돼있음
  
      - File의 크기가 1.4MB라고 가정
      - Memory는 File의 크기보다 작게 설정
        - 통째로 한 방에 읽는 것이 아니라 끊어서 읽음 (Read)
        - **비유** : 퍼즐 전체를 조각내서 가져와 Memory에 쌓임 / ***이 전체가 Stream 인가?***
  
    - Scoket에서의 분해가 중요
  
      - 여기도 **Buffer**가 있을 수 있는데, Memory 에서의 데이터를 카피 → 이를 Buffered I/O
      - TCP가 이렇게 가지고 있다가 IP쪽으로 내려갈때, 이 데이터들을 잘게 쪼갠 것을 Segment
        - **비유 :** Memory에 쌓인 퍼즐 조각이 그대로 이곳의 Buffer로 옴
        - Segment로의 분해가 일어날 때 각 퍼즐 조각에 번호가 붙음
  
    - 트럭 (Frame)의 목적지는 ?
  
      - 도착지 PC의 File에 연결된 File I/O Buffer가 있음
      - **TCP Buffer**도 있음
      - 트럭에서 박스를 빼면 트럭은 사라지고, Packet을 뜯으면 Segment가 나옴 (Decapsulation)
      - TCP Buffer의 크기를 **Window Size** (수신측에서 Segment가 날라오면 조립해서 집어넣는 공간)
  
    - 수신측은 서버측에 데이터를 잘 수신했다고 통신을 보냄 = ACK (
  
      필요한 데이터의 번호 + Window size와 함께
  
      )
  
      - 서버는 데이터를 잘 보내고 Wait을 함. ACK+데이터번호 를 기다림
        - 이 과정 때문에 속도 지연 발생
      - 수신측의 ACK에서 보내온 Window size에 서버측의 데이터가 들어갈 **공간이 없다면 데이저 송신을 중지**! = **Wait이 걸림**
  
    - 송수신 시간을 단축하기 위해서는 수신측의 
  
      Receive 속도가 중요함
  
      - TCP Buffer에서 File I/O Buffer로 파일을 빨리 올려야 함
      - Read (Process 가 Socket을 읽는 것) 속도가 Network에서 수신(Segment가 TCP Buffer에 쌓이는 것)하는 속도 보다 빨랴아함. 느리면 Window size가 점점 좁아짐
      - 이러한 문제가 발생하면 Network에서 원인을 찾는 것이 아니라 Process에서 찾아야 한다
  
    - 결론! Server 측에서의 송신이 느린 것인지 Client 측에서의 수신이 느린 것인지 구별할 줄 알아야 함
  
    ## 26. TCP 연결이라는 착각에 대해
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d34db77e-a927-41a6-b9fb-ef8c0c14f791/Untitled.png)
  
    - TCP 연결에 대해 보안적으로 본다면 TCP 연결은 보안성이 없다
      - 보안의 3대 요소 중 **기밀성**과 **무결성**이 충족하지 않는다는 것
    - 보안의 3대 요소
      - 기밀성 : 통신 당사자들끼리만 내용을 알아야 함
      - 무결성 : ‘변경’은 허락된 사람에게서 인가된 매커니즘만을 통해서만 이뤄져야 함
      - 가용성 : 정보가 사용 가능해야 함
    - TCP 연결을 위한 3Way-Handshake는 시퀀스 및 MSS, SACK(혼잡제어정책)을 교환하는 행동이며 이 과정에는 보안성이 없다
  
    ## 27. TCP 연결 & LAN선 뽑기 & 게임 해킹
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b91fcd8-8df2-4d17-8c5f-78cd563cb0bd/Untitled.png)
  
    - LAN 케이블을 뽑으면 TCP 연결은 어떻게 될까?
      - TCP 연결이 성립된다는 것은 물리적으로 통신이 가능한 상태라는 전제조건이 있다
      - 만약 File을 다운로드 받을 때 LAN 케이블을 뽑는다면?
        - 일정 시간 동안 뽑았다 꽂으면 멈췄던 프로세스가 다시 작동할 수 있다
      - 뽑혀있는 시간이 늘어나서 프로세스가 아예 작동을 안 할 때는 네트워크에 충격이 생겼다고 한다
      - LAN 케이블이 뽑혔어도 네트워크 연결을 허용하는 시간은 어떻게 개발하느냐에 따라 다르다
    - 네트워크 연결 관리를 할 때, 물리적 네트워크 충격이 있는데 프로그램이 인지를 못하는 것인지 아니면 아예 신경을 안 써도 되는 것인지 확인하면서 프로그램을 개발해야 한다
  
    ## 28. Unicast, Broadcast, Multicast
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ffb99b8-16fd-4daa-9245-f8b017344078/Untitled.png)
  
    - Unicast : 하나의 상대방에게만 정보를 전달
    - Broadcast : 연결되어 있는 모든 상대방에게 정보를 전달
      - 브로드캐스트를 하는 동안에는 이더넷 환경의 CSMA/CD (Carrier Sense Multiple Access / Collision Detection ) 프로토콜에 의해 어디에서도 신호를 보낼 수가 없기 때문에 네트워크의 효율이 떨어지게 된다. 따라서 브로드 캐스트를 최소화를 하는 것이 중요하다. (브로드캐스트는 호스트 주소의 끝자리가 다 1이다.)
    - Multicast : 브로드캐스트와 비슷하지만 등록된 상대방에게만 정보를 전달
      - 이 때 쓰이는 프로토콜이 IGMP(Internet Group Management Protocol) 이다
      - IPTV와 같은 멀티캐스트 실시간 전송을 위한 프로토콜이다
  
    ## 29. IP 주소의 종류와 특징
  
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c5f9fbf-c010-4d69-97a6-389466a21e79/Untitled.png)
  
    > # **bit, byte**
    >
    > | 비트수                 | 표현 가능한 수         | 10진수로 변환가능한 수 |
    > | ---------------------- | ---------------------- | ---------------------- |
    > | 1bit                   | 0, 1                   | 0과 1                  |
    > | 2bit                   | 00, 01, 10, 11         |                        |
    > | (2의 2승만큼)          | 0부터 3까지            |                        |
    > | 4bit                   | 0000, 0001, 0010, 0011 |                        |
    > | 0100, 0101, 0110, 0111 |                        |                        |
    > | 1000, 1001, 1010, 1011 |                        |                        |
    > | 1100, 1101, 1110, 1111 |                        |                        |
    > | (2의 4승 만큼)         | 0부터 15까지           |                        |
    > | 8bit                   | 00000001, 00000010     |                        |
    > | …                      |                        |                        |
    > | (중략)                 |                        |                        |
    > | …                      |                        |                        |
    > | 11111100, 11111101     |                        |                        |
    > | 11111110, 11111111     |                        |                        |
    > | (2의 8승 = 256)        | 0부터 255까지          |                        |
    >
    > |
    >
    > - 8bit 와 Byte
    >
    >   Byte는 8개의 bit를 가진 8bit를 가르킴. 정보교환의 기본단위로 사용
  
    - Global IP
  
      - 인터넷에서 Global IP가 같은 경우는 없다.
      - Router는 Global IP에 대해서만 Routing을 한다
  
    - Private IP
  
      - 작은 소규모 인터넷을 구축할 때
  
      - 4가지 클래스가 있음
  
        1. A : Network = 8bit, Host = 24bit / 컴퓨터가 `2^24`개 있을 수 있는 초거대 네트워크
        2. B : Network = 16bit, Host = 16bit / 큰 대학교 정도
        3. C : Network = 24bit, Host = 8bit / 일반 기업
  
        - 각 클래스 별로 사설 IP가 정해져있음
        - C클래스의 사설 주소는 공유기에서 많이 쓰임 (192.168. x . x)
        - 원래 사설 IP로는 인터넷에 접속을 할 수 없는데, 공유기가 Global IP를 공유해주는 것
  
    - Loopback
  
      - 127.0.0.1 을 많이 씀
      - Host 자신을 의미한다
      - 프로세스 A를 클라이언트, 프로세스 B를 서버로 설정할 경우 서버의 IP 주소를 127.0.0.1로 설정하면 클라이언트의 프로세스로부터 데이터가 전달될 때, IP 수준까지 내려왔다가 라우팅이 외부로 빠져나가지 않고 그대로 서버의 프로세스로 올라간다
  
    - `IPC란? 가상 메모리 침범?`
  
    ## 30. 전세계 인터넷을 멈추는 방법과 DNS
  
    - DNS는 분산형 DB 구조를 갖고 있음. 이 구조는 계층적 구조
      - 여기서 최상단에 있는 것이 Root. `Root DNS`는 전세계에 13대가 있음. 이 13대를 마비시키면 전세계 인터넷은 멈춘다
    - DNS를 만든 이유 : 숫자로 표현된 IP 주소는 외우기 힘들기 때문
    - URL을 검색할 경우
      1. 자기 PC의 메모리를 뒤져 DNS Cache 부터 찾음. 없으면 → 2번 과정
      2. 여기에 naver.com이 없으면 hosts file을 찾음. 없으면 → 3번 과정
      3. DNS
         - 공유기가 DNS 포워딩을 제공해서 DNS의 역할을 해주기도 함
         - 공유기가 제공을 안하면 통신사(ISP)가 제공하는 DNS가 있음