# 네트워크 기초 이론

## 1. 네트워크를 배우려는 사람들을 위해

- OSI 7Layer 공부에 너무 애쓰지말자

완벽하게 개념을 다루고 있음. 개념과 사실 중 완벽하게 개념에 해당함

즉, TCP / IP + HTTP 등 (사실)을 배우고 싶은데 OSI 7Layer를 깊이 파는 순간 흥미를 잃게 됨

어떤 사람과 친해지고 싶다면 그 사람에 대해서 알아가야지, 그냥 사람이라는 개념에 대해서 알아갈 필요 없음

- **컴퓨터의 세상은 3개의 Layer로 이루어져 있다**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1032d916-ab42-49a9-85ea-f0e3b43f776a/Untitled.png)

  - 커널의 구성요소 ( TCP/ IP ) 를 유저모드 애플리케이션으로 추상화 한 것은 File이 아니라 **Socket** 이라고 부름

  - 각 계층들이 어떻게 구현이 되는가가 중요!

  - 식별자

     (Tcp의 port번호, Network의 IP주소, Access의 Mac주소)

    - 무엇에 대한 식별자인가? (2. 에서 계속)

## 2. MAC, IP, Port 번호가 실벽하는 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ac6b9060-fca3-4349-b191-3f1eaad7b87e/Untitled.png)

- NIC ( Network Interface Card ) = Lan 카드에 대한 **식별자** / MAC 주소 혹은 하드웨어 주소는 자주 변경되지 않는다. (즉, 변경은 가능하다)

- IP주소는 **Host (인터넷이 연결된 PC)**에 대한 

  식별자

  - IP주소는 NIC 1개에 여러 개를 바인딩 할 수 있으므로, PC 한 대는 n개의 IP 주소를 갖을 수 있다.

- Port는 인터페이스라고 생각! Port 번호가 실별자가 되어 주는 것? 번호에 관한 대답으로 상대방의 직업을 유추 가능

  1. SW개발, 관리 하는 사람들에게 Port 번호가 무엇인가를 물으면 Process? 라고 대답
  2. Network 개발자에게 Port 번호가 무엇인가를 물으면 Service? 라고 대답
  3. 물리적으로 Network, 통신 공사를 하는 사람들에게 물으면 Interface 번호? 라고 대답

## 3. Host, Switch, Network의 관계

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b426d956-c164-4121-88ca-471f6e5e6e4b/Untitled.png)

- Host (=Computer + Network )는 크게 보면 다음과 같이 나눌 수 있음

  1. Network 자체를 이루는 경우 = **Switch** (Router, F/W(방화벽), IPS(보안장비))

     1. F/W와 IPS는 보안 스위치라고도 부름

        Router는 경로설정 (길찾는 것)

  2. Network의 이용주체인 경우 = **End-point.** End point는 ****역할에 따라 Peer, Server, Client로 나눔

- 스위치는 계층이 높아질 수록 그 계층에 대한 가격이 높아짐 ex) L7 스위치 (HTTP를 스위칭)가 가장 비쌈

- **인터넷이란 Router와 DNS의 거대한 집합체**

```
스위치가 무엇일까? 공유기도 스위치인가?
```

## 4. IPv4 주소 체계에 대한 암기사항

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/094d06f4-8dfa-42c2-a442-47e7113b66be/Untitled.png)

- IP (Internet Protocol) 주소는 Host에 대한 식별자. 사람으로 치면 주민등록번호와 같은 것

  > Protocol = 규정, 규약, 규칙

  - 비유 = 대한민국 행정체계 (Network), 개인(Host), 주민등록번호(IP)
  - **IPv4는 32bit, IPv6는 128bit 주소체계**
  - Internet에 전 세계인이 모두 참여한다면 IPv4의 경우의 수를 초과

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18b3adb0-c6a4-41de-8105-4eee3cd97ef8/Untitled.png)

- IPv4에서 

  ```
  .
  ```

  으로 구분되는 숫자들의 범위는 0~255인데, 이는 

  ```
  2^8 = 8bit
  ```

   이다.

  - 즉 8bit 씩 4번 끊어서 표시 = 32bit
  - 넷 마스크를 이해하기 위해 Binary 값을 2진수, 16진수로 변환할 줄도 알아야 함 (’192’ - > 1100 0000 - > C0)
  - IP주소는 Net ID + Host ID (총 32)

- Net mask란 IP 주소에서 Net ID의 길이가 얼마인지를 나타내는 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09c2e938-95da-4248-a6ea-85b96c1673fc/Untitled.png)

- IPv4 주소 `192.168.60.14` 에서 Netmask 주소 `255.255.255`를 bit의 AND 연산하여 Net ID를 구분. `192.168.60.14 / 24` 와 같이 앞의 24bit가 Net ID임을 알려주는 표기법도 존재

## 5. 개발자 입장에서 Port번호 이해하기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9eef5337-cf83-484e-9ea9-af2feabf30f6/Untitled.png)

- **Port는 명백히 Process의 식별자다!** (개발자 입장)
- Socket은 TCP/IP Port 정보를 전달 받는데, 16bit 정보이다 = Port번호는 Socket에 바인딩 된다
  - `2^16` 개, 0~65535의 범위를 갖는데, 여기서 0과 65535는 쓰지 않는다
- Packet의 경로는 NIC ~ Process 까지 순차적으로 올라가는데, 4계층에서 어느 Process로 갈 건지는 Port 번호로 결정된다

## 6. Switch가 하는 일은 Switching 이다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bb141c3f-4e52-4196-9a2d-2c4172510b77/Untitled.png)

- Switch는 교차로, Switching은 경로 선택
- Internet은 Router의 집합체 (Router는 기본적으로 L3 스위칭)
  - 즉, 비유를 들고 있는 Network라는 고속도로에서 Router는 교차로가 됨
  - Router들끼리 어떤 프로토콜을 갖고 통신을 해서 최적화 된 경로를 선정함
  - 몇 개의 Router들이 손상됐다고 해도 구조가 망가지지 않음
  - 자동차는 Packet임
  - 이정표는 **라우팅 테이블** 를 근거로 목적지에 도착

## 7. 네트워크 데이터 단위 정리 (매우 중요!)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a04f010-7d27-4188-b051-ddb05f8fd26f/Untitled.png)

- Socket에서 다루는 데이터 단위는 

  Stream

  - Stream : 시작은 알지만 끝은 모름
  - Socket을 Network단으로 보내면 Stream 데이터가 Segment화 된다 (데이터를 자름) = Segmentaion

- TCP에서 다루는 데이터 단위 

  Segment

  - Socket에서 받은 잘린 Stream 데이터
  - MSS (Maximum Segment Size) 일정 길이의 최대값. MSS는 MTU보다 당연히 작다

- IP에서 다루는 데이터 단위 

  Packet

  - Segment를 인터넷 환경에서 전송 가능한 상태로 포장한 형태
  - MTU (Maximum Trasnport Unit) 특별한 이유가 없다면 1500bytes

- H/W단에서 다루는 데이터 단위 

  Frame

  - Packet을 실어 나를 때는 다시 Frame 데이터에 넣는다

```
User모드에서의 데이터가 어떻게 분해되어 Kerner, H/W단에서의 전송 가능한 형태가 되는지 알자
```

## 8. 네트워크 인터페이스 선택 원리와 기준

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d9fbf4c0-958e-446b-8dad-e5f6f32e5330/Untitled.png)

- IP, NIC(유선, 무선), 통신사가 2개일때 어떤 루트를 통해 열릴까?
- PC에 한해서는 주로 메트릭(비용) 값으로 결정

## 9. 웹 서비스를 만든 사람에 대하여

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1836416b-6bd6-4c2c-acb8-d0d2456015e7/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd8625f3-b9b4-44b0-9443-c7ec41baccf1/Untitled.png)

- Web이란 용어의 탄생 배경
  - IT 역사의 위대한 55년생 양띠 3인 (스티브 잡스, 빌 게이츠, 티모시 버너스 리)
  - 티모시 버너스 리
    - Web의 창시자
    - CERN (입자물리연구소) 연구원이었음
    - 논문을 단순히 읽기만 하는 것이 아니라 링크를 서로 참조하여 지식의 확장이 가능하게 하기 위해 만든 문서 (TEXT + LINK) 형식 = **HTML**
    - HTML을 인터넷 연결을 통해 전달하기 위한 프로토콜 = **HTTP**
    - 문서들의 연결이 거미줄 같다하여 Web = **HTML + HTTP**
    - 문서를 다루는 SW의 3대 요소
      1. 인터페이스
      2. 제어체계
      3. Database

## 10. 초창기 웹 서비스 구조 & 웹 서비스 3대 요소 (복습 필요)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8229af63-c8fd-4a38-a916-ba7b7b8dd8e6/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff6de678-4c80-44e3-a27c-f936e2d07cb5/Untitled.png)

- 유지보수 편의성을 극대화하기 위해 자료구조 (**HTML**), UI (**CSS**), 제어체계 (**JavaScript**)로 나눔
- HTTP에는 1.0 / 1.1 / 2.0 / 3.0 버전이 있는데 1.1가 가장 많이 쓰이고 있으며, 현재는 2.0으로 빠르게 넘어가는 추세
- HTTP 통신 프로토콜의 가장 중요한 특징 = Stateless (상태가 없음)
  - 연결이라는 것은 상태의 개념을 포함하는데, HTTP에서는 상태 개념이 없다
- HTTP 1.0 시절 Browser는 ‘원격지’ 문서뷰어 느낌. 브라우저는 요청받은 HTML을 처리할 때 다음과 같은 순서로 작동
  1. 파싱하여 구문분석 > 자료구조 (비선형 트리구조?) DOM / **Parser**
  2. 화면에 렌더링 / **렌더링 엔진**
  3. 연산 주체가 되는 **스크립트 엔진** ex) JavaScript → 실행은 클라이언트 브라우저에서 이루어짐
  4. HTML, CSS, IMG, JavaScript이 포함된 파일을 다루며 모두 정적 자료
- 단방향 작용 (클라이언트의 요청과 서버의 응답)
- DNS (Domain Name Service) 가 URL을 받으면 IP주소를 넘겨주는 식으로 작동
- 예전에는 Web Server가 처리, 송신을 모두 다 했지만, 최근에는 처리(연산) 주체가 생김
- 양방향 상호 작용으로 변하면서 문제가 발생
  - 문맥이 생김 ( 상태가 나오고 전이됨 ) → **기억, 기록**을 해야함. 이 기록은 클라이언트, 서버 양측에서 모두 이루어져야 함
  - 어딘가에는 이런 기록을 저장해야 할 필요가 생김 → **DB**의 등장 (서버측)
  - 클라이언트 쪽에서는 Cookie의 등장 ( 클라이언트측)
    - Cookie는 Key + Value, 속성으로는 범위 + 기간으로 이루어짐
- DB와 처리 주체의 연결 방식이 다양함 ex) SQL
  - Post로 받은 것을 처리 주체가 쿼리문으로 처리
  - 위와 같이 동적으로 생성된 HTML을 반환