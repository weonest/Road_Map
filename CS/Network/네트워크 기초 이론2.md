# 네트워크 기초 이론2

## 12. WAS, JVM

### 웹(WEB)서버란 무엇일까? (https://velog.io/@developerjun0615)

- 사전적 의미
  - 웹 서버 (하드웨어) : WEB 서버가 설치되어 있는 컴퓨터
  - 웹 서버 (소프트웨어) : 클라이언트로부터 HTTP 요청을 받아 정적 컨텐츠 (HTML, IMG, CSS 등) 를 제공하는 컴퓨터 프로그램
- 개념
  - 정적 컨텐츠 제공 : WAS를 거치지 않고 바로 자원을 제공
  - 동적 컨텐츠 제공 : 클라이언의 request를 WAS에 보내기
- 정적, 동적 컨텐츠란?
  - 정적 컨텐츠(static) :변화가 없는 컨텐츠, 어느 사용자에게나 동일한 결과값을 보여줌 (HTML, IMG, CSS 등)
  - 동적 컨텐츠 (dynamic) : 배너 광고나 카테고리 등 모두가 볼 수 있어야 하는 컨텐츠는 정적으로 두고, 마이페이지나 장바구니 등 사용자 맞춤형 정보를 제공해야 할 때에는 동적 컨텐츠를 사용 (DB, 비즈니스 로직)
- 종류
  - Apache Server
  - Nginx
  - IIS
  - WebToB

### 웹 애플리케이션 서버(WAS, Web Applicaiton Server)란?

- 개념
  - DB 조회나 로직 처리를 요구하는 동적 컨텐츠를 제공하기 위해 만들어진 Application Server
  - **Web Container** 혹은 **Servlet Container** 라고도 불린다
  - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다
- 기능
  - 프로그램 실행 환경과 DB 접속 기능 제공
  - 여러 개의 트랜잭션 관리 기능
  - 업무 처리하는 비느지스 로직 수행
  - ex) **Tomcat**, Websphere, Weblogic, Jeus, JBoss, Resin 등

![https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F580cc763-4b90-40ea-92c8-b738185089eb%2Fimage.png](https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F580cc763-4b90-40ea-92c8-b738185089eb%2Fimage.png)

### WAS의 종류와 특징

- Tomcat 기능
  - JSP/Servlet Container 중 하나로 사용자에게 JSP 요청을 받으면 Servlet으로 바꾸어 실행
  - Web Server에서 요청한 동적 페이지를 읽어 프로그램을 실행
  - 그 결과를 다시 **HTML로 재구성하여 Web Server** 에게 전달
- Tomcat의 특징
  - Servlet Container를 지원함
  - 플랫폼에 제약이 없음 (Windows, Linux, Unix 등)

### Servlet 이란?

- 개념

  - 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술
  - Java를 사용하여 웹을 만들기 위해 필요한 기술
  - 클라잉너트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주는 역학을 하는 Java 프로그램

- 특징

  - 클라이언트의 요청에 대해 동적으로 작동하는 웹 애플리케이션 컴포넌트
  - HTML을 사용하여 요청에 등답한다
  - Java Thread를 이용하여 동작한다
  - MVC 패턴에서 **Controller**로 이용된다
  - HTTP 프로토콜 서비스를 지원하는 javax.servlet.httpHTTPServlet 클래스를 상속받는다

  “

  ![https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F5b1a84ef-e29c-49be-ae12-2e597c5c68af%2F2021-11-03_15-16-59.png](https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F5b1a84ef-e29c-49be-ae12-2e597c5c68af%2F2021-11-03_15-16-59.png)

- 동작방식

1. 사용자(클라리언트)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송한다
2. 요청을 전송받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성한다
3. web.xml을 기반으로 사용자가 요청한 URL이 어느 Servlet에 대한 요청인지 찾는다
4. 해당 Servlet에서 service 메소드를 호출한 후 클라이언트의 Get, POST 여부에 따라 doGet() 또는 doPost()를 호출한다
5. doGet() 또는 doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다
6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다

### Servelt Container 란?

- 서버에 서블릿을 만들었다고 해서 스스로 작동하는 것이 아니라 서블릿을 관리해주는 것이 필요한데, 그 역학을 하는 것이 바로 서블릿 컨테이너
- 서블릿은 실제 행동을 수행하고, 서블릿 컨테이너는 클라이언트의 요청을 받아주고 응답할 수 있게, 웹서버와 소켓으로 통신하며 대표적인 예로 Tomcat이 있다
- 톰캣은 실제로 웹 서버와 통신하며 JSP와 Servlet이 작동하는 환경을 제공해준다

### JSP (Java Server Page)

- 개념
  - Java 코드가 들어가 있는 HTML 코드
- 특징
  - Servlet은 자바 소스코드 속에 HTML 코드가 들어가 있는 형태인데, JSP는 이와 반대로 HTML 소스코드 속에 자바 소스코드가 들어가는 구조를 갖는 웹 애플리케이션 프로그래밍 기술이다
  - JSP는 WAS에 의하여 서블릿 클래스로 변환되어 사용된다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9ea015f-56f6-42c3-9566-e9b0c9906d26/Untitled.png)

- JSP 동작 구조

1. 웹 서버가 사용자로부터 서블릿에 대한 요청을 받으면 서블릿 컨테이너에 그 요청을 넘긴다.
2. 요청을 받은 컨테이너는 HttpRequest와 HttpResponse 객체를 만들어, 이들을 통해 서블릿 doPost()나 doGet() 메소드 중 하나를 호출한다
3. 만약 서블릿만 사용하여 사용자가 요청한 웹페이지를 보여주려면 out 객체의 println 메소드를 사용하여 HTML 문서를 작성해야 하는데 이는 추가/수정을 어렵게 하고, 가독성도 떨어지기 때문에 JSP를 사용하여 비즈니스 로직과 프레젠테이션 로직을 분리한다
4. 여기서 서블릿은 데이터의 입력, 수정 등에 대한 제어를 JSP에게 넘겨서 프레젠테이션 로직을 수행한 후 컨테이너에게 Response를 전달
5. 이렇게 만들어진 결과물은 해당 페이지를 요청하면 컴파일이 되어 자바파일을 통해 .class 파일이 만들어지고, 두 로직이 결합되어 클래스화 되는 것을 확인할 수 있다.

### JVM (https://doozi0316.tistory.com)

- Java Virtual Machine의 줄임말로, ‘자바를 실행하기 위한 가상 기계’ 라고 할 수 있다
- Java는 OS에 종속적이지 않다는 특징을 갖고 있다. OS에 종속받지 않고 실행되기 위해선 OS 위에서 Java를 실행시킬 무언가가 필요한데, 그게 바로 JVM이다. 즉, OS에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터이다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24e5bf0d-28f2-412d-b425-0f8e4f509830/Untitled.png)

Java 원시코드 `.java`는 CPU가 인식을 하지 못하기에 기계어로 컴파일을 해줘야 한다. 하지만, Java는 이 JVM이라는 가상머신을 거쳐서 OS에 도달하기 때문에 OS가 인식할 수 있는 기계어로 바로 컴파일 되는 게 아니라 JVM이 인식할 수 있는 `.class`로 변환된다. Java compiler가 `.java`를 `.class` 라는 Java bytecode로 변환한다.

> 여기서 Java compiler는 JDK를 설치하면 bin에 존재하는 javac.exe 를 말한다. (즉, JDK에 Java compiler가 포함되어 있다) javac 명령어를 통해 .java 를 .class로 컴파일 할 수 있다.

변환된 bytecode는 기계어가 아니기 때문에 OS에서 바로 실행되지 않는다. 이때 JVM이 OS가 bytecode를 이해할 수 있도록 해석해준다. 따라서 Bytecode는 JVM위에서 OS 상관없이 실행될 수 있는 것이다.

## 13. LAN과 WAN을 구별하는 방법

**(널널한 개발자 피셜)**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2d583ef-9d74-49ff-bd55-e72cc5a3886f/Untitled.png)

- 지역의 크기로 LAN, WAN을 나누는 것은 기준이 모호해서 별로
- WAN = Virtual Network = 광대역 네트워크 통신 프로토콜
- LAN = Physical Network
  - MAC 주소 = 48bit
- IP주소와 MAC주소에서 특수 주소가 있는데, 이를 방송 주소 라고 함
  - 방송 주소가 적용되는 범위 또한 LAN이라고 생각 함

## 14. 패킷의 생성 원리와 캡슐화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa275df1-2843-4535-b05c-f2e11fd6462d/Untitled.png)

- Segment는 TCP 헤더만 가진다. Segment를 `encapsulation` 하면 Packet이 된다
- Packet은 Header (앞) 와 Payload (뒤) 로 나뉜다
  - Header는 다시 IP (앞) 와 TCP (뒤) 로 나뉜다. 일반적인 경우 여기서의 IP, TCP는 각각 20byte
  - Paylaod의 크기가 MSS이다?
  - 택배가 Packet(L3) 이면, 송장이 Header, 내용물은 Segment (L4), 트럭은 Frame (L2)
  - Packet을 실어 나르기 위한 정보들이 Header에 담겨 있다
  - DPI = Deep Packet Inspection = Payload를 들여다 보는 것. 도감청? 주의

## 15. L2 스위치에 대해서

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad7c3caf-2095-4529-9e4f-0fda09ea869e/Untitled.png)

- L2 스위치 =  MAC 주소 스위칭(48 bit)

- Net = Switch의 집합체

- L2 Access Swtich = 

  End-point

  와 직접 만나는 스위치

  - 건물에서 방 하나로 비유

- L2 Distribution Swtich = 스위치를 위한 스위치

  - 건물에서 한 층으로 비유
  - Gateway 역할을 하는 Router로도 연결 / Router는 건물로 비유

- L2 Access에서 L2 Distribution으로의 트래픽 이동, **상위** 계층 스위치로 연결 되는 line  = **Uplink**

## 16. IP 헤더 형식과 의미 요약

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98d6e181-abad-42f1-860e-ccd7e9c63005/Untitled.png)

- MTU의 크기는 이론상 `2^16 = 64kbyte` 까지 가능하지만, 아직 현상 유지중 (1500byte)

- Options는 거의 없기에 IP 헤더는 위의 20bytes만 다루는 경우가 많다

- IHL = Internet Header Length는 주로 

  ```
  5
  ```

  다

  - `32비트`는 4바이트 이므로 IHL 값이 5면 5 * `32비트` 즉 `5 * 4`바이트가 됩니다.

- **TOS**는 찾아볼 것

- TTL = Time To Live (8bit = 2^8 = 0 ~ 255)

  - 인터넷 = Router의 거대한 집합체인데, 이 Router들이 Packet을 유통하는데, 가끔 목적지를 못 찾아가거나 뭔가 **문제가 발생하는 경우를 대비**하여 Router에서 Router로 지나갈때마다 **TTL 값이 1씩 감소.** TTL이 0이 되면 Router가 그 Packet을 버림

## 17. Wireshark의 내부구조와 작동원리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/687b0e2c-5914-43ac-a675-9f0ab62398e1/Untitled.png)

- TCP/IP 와 Driver 사이의 공간에 

  Filter

  가 들어갈 수 있음

  - Filter에서 통과시키는 경우는 Bypass, 걸렀다면 Drop

  - Traffic이 밖으로 나가면 Outbound, 안으로 들어오면 Inbound

  - 항상 Bypass 하며 감시하는 것은 Filter가 아닌 

    Sensor (수집)

    - 나의 정보가 아닌 타인의 정보를 수집하는 것에 법에 저촉될 수 있음
    - Out, Inbound 의 송수신 되는 데이터들을 모조리 읽어다가 위로 끌어올려 Wireshark에게 줌

- Wireshark가 하는 일 (스스로 

  Analyzer

  라고 함, 

  Sniffer

  라고 부르는 사람들도 있음)

  - Sensor의 정보 수집 목적에 따라 해석이 다르게 될 수 있음 = **윤리의식이 중요!**

  1. 디코딩 = 규칙, 규정에 맞게 해석해서 보여줌