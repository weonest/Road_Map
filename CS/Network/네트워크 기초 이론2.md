# 네트워크 기초 이론2

## 12. WAS, JVM

### 웹(WEB)서버란 무엇일까? (https://velog.io/@developerjun0615)

- 사전적 의미
  - 웹 서버 (하드웨어) : WEB 서버가 설치되어 있는 컴퓨터
  - 웹 서버 (소프트웨어) : 클라이언트로부터 HTTP 요청을 받아 정적 컨텐츠 (HTML, IMG, CSS 등) 를 제공하는 컴퓨터 프로그램
- 개념
  - 정적 컨텐츠 제공 : WAS를 거치지 않고 바로 자원을 제공
  - 동적 컨텐츠 제공 : 클라이언의 request를 WAS에 보내기
- 정적, 동적 컨텐츠란?
  - 정적 컨텐츠(static) :변화가 없는 컨텐츠, 어느 사용자에게나 동일한 결과값을 보여줌 (HTML, IMG, CSS 등)
  - 동적 컨텐츠 (dynamic) : 배너 광고나 카테고리 등 모두가 볼 수 있어야 하는 컨텐츠는 정적으로 두고, 마이페이지나 장바구니 등 사용자 맞춤형 정보를 제공해야 할 때에는 동적 컨텐츠를 사용 (DB, 비즈니스 로직)
- 종류
  - Apache Server
  - Nginx
  - IIS
  - WebToB

### 웹 애플리케이션 서버(WAS, Web Applicaiton Server)란?

- 개념
  - DB 조회나 로직 처리를 요구하는 동적 컨텐츠를 제공하기 위해 만들어진 Application Server
  - **Web Container** 혹은 **Servlet Container** 라고도 불린다
  - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다
- 기능
  - 프로그램 실행 환경과 DB 접속 기능 제공
  - 여러 개의 트랜잭션 관리 기능
  - 업무 처리하는 비느지스 로직 수행
  - ex) **Tomcat**, Websphere, Weblogic, Jeus, JBoss, Resin 등

![https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F580cc763-4b90-40ea-92c8-b738185089eb%2Fimage.png](https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F580cc763-4b90-40ea-92c8-b738185089eb%2Fimage.png)

ㅇ

### WAS의 종류와 특징

- Tomcat 기능
  - JSP/Servlet Container 중 하나로 사용자에게 JSP 요청을 받으면 Servlet으로 바꾸어 실행
  - Web Server에서 요청한 동적 페이지를 읽어 프로그램을 실행
  - 그 결과를 다시 **HTML로 재구성하여 Web Server** 에게 전달
- Tomcat의 특징
  - Servlet Container를 지원함
  - 플랫폼에 제약이 없음 (Windows, Linux, Unix 등)

### Servlet 이란?

- 개념

  - 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술
  - Java를 사용하여 웹을 만들기 위해 필요한 기술
  - 클라잉너트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송해주는 역학을 하는 Java 프로그램

- 특징

  - 클라이언트의 요청에 대해 동적으로 작동하는 웹 애플리케이션 컴포넌트
  - HTML을 사용하여 요청에 등답한다
  - Java Thread를 이용하여 동작한다
  - MVC 패턴에서 **Controller**로 이용된다
  - HTTP 프로토콜 서비스를 지원하는 javax.servlet.httpHTTPServlet 클래스를 상속받는다

  “

  ![https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F5b1a84ef-e29c-49be-ae12-2e597c5c68af%2F2021-11-03_15-16-59.png](https://velog.velcdn.com/images%2Fdeveloperjun0615%2Fpost%2F5b1a84ef-e29c-49be-ae12-2e597c5c68af%2F2021-11-03_15-16-59.png)

- 동작방식

1. 사용자(클라리언트)가 URL을 입력하면 HTTP Request가 Servlet Container로 전송한다
2. 요청을 전송받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성한다
3. web.xml을 기반으로 사용자가 요청한 URL이 어느 Servlet에 대한 요청인지 찾는다
4. 해당 Servlet에서 service 메소드를 호출한 후 클라이언트의 Get, POST 여부에 따라 doGet() 또는 doPost()를 호출한다
5. doGet() 또는 doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보낸다
6. 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다

### Servelt Container 란?

- 서버에 서블릿을 만들었다고 해서 스스로 작동하는 것이 아니라 서블릿을 관리해주는 것이 필요한데, 그 역학을 하는 것이 바로 서블릿 컨테이너
- 서블릿은 실제 행동을 수행하고, 서블릿 컨테이너는 클라이언트의 요청을 받아주고 응답할 수 있게, 웹서버와 소켓으로 통신하며 대표적인 예로 Tomcat이 있다
- 톰캣은 실제로 웹 서버와 통신하며 JSP와 Servlet이 작동하는 환경을 제공해준다

### JSP (Java Server Page)

- 개념
  - Java 코드가 들어가 있는 HTML 코드
- 특징
  - Servlet은 자바 소스코드 속에 HTML 코드가 들어가 있는 형태인데, JSP는 이와 반대로 HTML 소스코드 속에 자바 소스코드가 들어가는 구조를 갖는 웹 애플리케이션 프로그래밍 기술이다
  - JSP는 WAS에 의하여 서블릿 클래스로 변환되어 사용된다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9ea015f-56f6-42c3-9566-e9b0c9906d26/Untitled.png)

- JSP 동작 구조

1. 웹 서버가 사용자로부터 서블릿에 대한 요청을 받으면 서블릿 컨테이너에 그 요청을 넘긴다.
2. 요청을 받은 컨테이너는 HttpRequest와 HttpResponse 객체를 만들어, 이들을 통해 서블릿 doPost()나 doGet() 메소드 중 하나를 호출한다
3. 만약 서블릿만 사용하여 사용자가 요청한 웹페이지를 보여주려면 out 객체의 println 메소드를 사용하여 HTML 문서를 작성해야 하는데 이는 추가/수정을 어렵게 하고, 가독성도 떨어지기 때문에 JSP를 사용하여 비즈니스 로직과 프레젠테이션 로직을 분리한다
4. 여기서 서블릿은 데이터의 입력, 수정 등에 대한 제어를 JSP에게 넘겨서 프레젠테이션 로직을 수행한 후 컨테이너에게 Response를 전달
5. 이렇게 만들어진 결과물은 해당 페이지를 요청하면 컴파일이 되어 자바파일을 통해 .class 파일이 만들어지고, 두 로직이 결합되어 클래스화 되는 것을 확인할 수 있다.

### JVM (https://doozi0316.tistory.com)

- Java Virtual Machine의 줄임말로, ‘자바를 실행하기 위한 가상 기계’ 라고 할 수 있다
- Java는 OS에 종속적이지 않다는 특징을 갖고 있다. OS에 종속받지 않고 실행되기 위해선 OS 위에서 Java를 실행시킬 무언가가 필요한데, 그게 바로 JVM이다. 즉, OS에 종속받지 않고 CPU가 Java를 인식, 실행할 수 있게 하는 가상 컴퓨터이다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24e5bf0d-28f2-412d-b425-0f8e4f509830/Untitled.png)

Java 원시코드 `.java`는 CPU가 인식을 하지 못하기에 기계어로 컴파일을 해줘야 한다. 하지만, Java는 이 JVM이라는 가상머신을 거쳐서 OS에 도달하기 때문에 OS가 인식할 수 있는 기계어로 바로 컴파일 되는 게 아니라 JVM이 인식할 수 있는 `.class`로 변환된다. Java compiler가 `.java`를 `.class` 라는 Java bytecode로 변환한다.

> 여기서 Java compiler는 JDK를 설치하면 bin에 존재하는 javac.exe 를 말한다. (즉, JDK에 Java compiler가 포함되어 있다) javac 명령어를 통해 .java 를 .class로 컴파일 할 수 있다.

변환된 bytecode는 기계어가 아니기 때문에 OS에서 바로 실행되지 않는다. 이때 JVM이 OS가 bytecode를 이해할 수 있도록 해석해준다. 따라서 Bytecode는 JVM위에서 OS 상관없이 실행될 수 있는 것이다.

## 13. LAN과 WAN을 구별하는 방법

**(널널한 개발자 피셜)**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2d583ef-9d74-49ff-bd55-e72cc5a3886f/Untitled.png)

- 지역의 크기로 LAN, WAN을 나누는 것은 기준이 모호해서 별로
- WAN = Virtual Network = 광대역 네트워크 통신 프로토콜
- LAN = Physical Network
  - MAC 주소 = 48bit
- IP주소와 MAC주소에서 특수 주소가 있는데, 이를 방송 주소 라고 함
  - 방송 주소가 적용되는 범위 또한 LAN이라고 생각 함

## 14. 패킷의 생성 원리와 캡슐화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa275df1-2843-4535-b05c-f2e11fd6462d/Untitled.png)

- Segment는 TCP 헤더만 가진다. Segment를 `encapsulation` 하면 Packet이 된다
- Packet은 Header (앞) 와 Payload (뒤) 로 나뉜다
  - Header는 다시 IP (앞) 와 TCP (뒤) 로 나뉜다. 일반적인 경우 여기서의 IP, TCP는 각각 20byte
  - Paylaod의 크기가 MSS이다?
  - 택배가 Packet(L3) 이면, 송장이 Header, 내용물은 Segment (L4), 트럭은 Frame (L2)
  - Packet을 실어 나르기 위한 정보들이 Header에 담겨 있다
  - DPI = Deep Packet Inspection = Payload를 들여다 보는 것. 도감청? 주의

## 15. L2 스위치에 대해서

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad7c3caf-2095-4529-9e4f-0fda09ea869e/Untitled.png)

- L2 스위치 =  MAC 주소 스위칭(48 bit)

- Net = Switch의 집합체

- L2 Access Swtich = 

  End-point

  와 직접 만나는 스위치

  - 건물에서 방 하나로 비유

- L2 Distribution Swtich = 스위치를 위한 스위치

  - 건물에서 한 층으로 비유
  - Gateway 역할을 하는 Router로도 연결 / Router는 건물로 비유

- L2 Access에서 L2 Distribution으로의 트래픽 이동, **상위** 계층 스위치로 연결 되는 line  = **Uplink**

## 16. IP 헤더 형식과 의미 요약

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98d6e181-abad-42f1-860e-ccd7e9c63005/Untitled.png)

- MTU의 크기는 이론상 `2^16 = 64kbyte` 까지 가능하지만, 아직 현상 유지중 (1500byte)

- Options는 거의 없기에 IP 헤더는 위의 20bytes만 다루는 경우가 많다

- IHL = Internet Header Length는 주로 

  ```
  5
  ```

  다

  - `32비트`는 4바이트 이므로 IHL 값이 5면 5 * `32비트` 즉 `5 * 4`바이트가 됩니다.

- **TOS**는 찾아볼 것

- TTL = Time To Live (8bit = 2^8 = 0 ~ 255)

  - 인터넷 = Router의 거대한 집합체인데, 이 Router들이 Packet을 유통하는데, 가끔 목적지를 못 찾아가거나 뭔가 **문제가 발생하는 경우를 대비**하여 Router에서 Router로 지나갈때마다 **TTL 값이 1씩 감소.** TTL이 0이 되면 Router가 그 Packet을 버림

## 17. Wireshark의 내부구조와 작동원리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/687b0e2c-5914-43ac-a675-9f0ab62398e1/Untitled.png)

- TCP/IP 와 Driver 사이의 공간에 

  Filter

  가 들어갈 수 있음

  - Filter에서 통과시키는 경우는 Bypass, 걸렀다면 Drop

  - Traffic이 밖으로 나가면 Outbound, 안으로 들어오면 Inbound

  - 항상 Bypass 하며 감시하는 것은 Filter가 아닌 

    Sensor (수집)

    - 나의 정보가 아닌 타인의 정보를 수집하는 것에 법에 저촉될 수 있음
    - Out, Inbound 의 송수신 되는 데이터들을 모조리 읽어다가 위로 끌어올려 Wireshark에게 줌

- Wireshark가 하는 일 (스스로 

  Analyzer

  라고 함, 

  Sniffer

  라고 부르는 사람들도 있음)

  - Sensor의 정보 수집 목적에 따라 해석이 다르게 될 수 있음 = **윤리의식이 중요!**

  1. 디코딩 = 규칙, 규정에 맞게 해석해서 보여줌

## 18. Router의 내부 구조와 Inline

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b94c9ba3-76c3-4622-9d74-9dc761032682/Untitled.png)

- 단순히 Router 내부 구조라기보다는 Inline 구조를 갖는 장치에 대해 설명하는 시간
- Router는 L3 스위치의 한 종류이다
  - (L3 스위치는 패킷을 가지고 스위칭)
- 하나의 PC가 네이버로 접속을 한다고 할 때, 여러개의 Router들을 거치게 된다. 이때 거치게 되는 Router들에는 IP주소도 부여가 되고, 각 Router들을 하나의 Host로 볼 수 있다. 즉, Router를 하나의 컴퓨터로 볼 수 있는 것.
  - 보통 Router 하나에 연결되는 인터페이스는 두 개 (내부, 외부)
- Inline 구조는 패킷이 1번 NIC를 통해 OSI 7계층을 밑에서부터 Uplink하면서 거친 뒤 다시 Downlink 하여 2번 NIC를 통해 외부로 나가는 구조이다
  - NIC#1 → TCP/IP → Process → TCP/IP → NIC#2 → 외부. 이와 같은 구조일 수 있겠다. 이때 User모드, Kernerl 모드, 하드웨어를 나누는 경계선을 건널 때마다 많은 전산비용이 들어간다. 또한 처리지연이 발생한다
  - 비용을 아끼기 위해서는 1번 → 2번 NIC로 곧바로 통과하는 것, 즉 하드웨어 수준에서 곧바로 처리되는 것이 가장 좋을 것이다 (하드웨어 수준에서 다 처리가 되는 것을 ‘가속했다’라고 표현)
- Inline 장치가 위의 과정을 처리할 수 있는 수준은 세 가지가 있다.
  1. User 모드에서 Process 수준
  2. Kernel 모드에서 TCP/IP 수준
  3. 하드웨어 영역에서 NIC 수준
- 패킷 단위 데이터를 단순 전송 할 경우 Router가 내부로 들어온 패킷을 외부로 내보낼 수도 있지만, 또 다른 Router로 보낼 수도 있다
  - 이 경우에는 IP 주소 수준에서 Read를 통해 패킷을 내부로 읽어들인 뒤 Writer를 통해 어떤 NIC로 보낼지 인터페이스를 선택해야 한다
  - 여기서 만약 Read만 하고 Write을 하지 않으면 패킷이 Drop
  - 패킷이 Drop 되는 경우로 첫 번째는 패킷을 어디로 보낼지 IP주소를 보고 선택해야 하는데, 적정한 주소가 없어서 Drop. 두 번째는 패킷이 외부로부터 내부로 들어오는 경우에 Drop되는 경우가 있다
- Inline 장비들은 항상 결정을 내려서 Bypass or Drop 처리를 해야 한다
  - 단지 Routing에 관련된 것만 한다면 Router가 되는 것이고, 보안적인 이유를 가지고 Bypass or Drop 처리를 한다면 방화벽이 되는 것
  - Router와 방화벽은 같은 L3 스위치의 일종이며 같은 내부구조를 가지고 있다

## 19. Inline 구조와 Out of path 구조

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/336aac2a-2ee0-4ab0-ae2e-fb11ef831a7f/Untitled.png)

- Network 디바이스는 주로 Inline이다

- Inline, Out of path는 **Packet**을 다룬다

- Router도 IP 주소가 여러개일 수 있다

- 주로 Gateway가 1번 IP를 갖는다

- 대략적으로 Router 기준으로 안쪽을 내부망, 바깥쪽을 외부망

- Network를 고속도로로 비유하면, Inline은 **톨게이트**로 비유

- Port Mirroring

  - 즉, **내용물은 같고 (Mirroring)** 내용물을 특정 Port에 Copy
  - CPU 사용량이 많이 올라 **과부하**가 걸리므로, 네트워크 관리자는 지양함

- Out of Path

   : (주로 Distribution 스위치에서) Router가 자신을 지나가는 정보를 Mirroring 한 것을 Read Only로 저장하는 곳

  - Router나 F/W(방화벽) 같은 것들은 Inline
  - 기본적으로 Seonsor(탐지)일 가능성이 높음
  - **과속감시 카메라**로 비유 (과속을 막진 않지만 탐지는 가능)
  - 읽은 정보로 장애를 대응 = **장애 대응 센서**
  - DPI 를 통해 침입을 확인 한다 = **NIDS**

- Tab Switch

   : 모두 Bypass 시키는데 Out of pass로 Copy 시켜줌

  - 1개의 Packet만 지나가도 모든 인터페이스에 Copy 시킴
  - CPU 사용량 높음
  - 목적이 다른 Sensor들 (장애, NIDS 등) 에게 보내주는 용도?

## 20. Proxy 구조와 작동원리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b3efff51-ca7a-4c1f-ba80-af712e27ac97/Untitled.png)

- Network을 이루는 수 많은 요소들은 기본적으로 Proxy, Inline, Out of path 중 하나이다
- 일반적인 경우 = PC (3.3.3.3) → Naver (5.5.5.5)  TCP/IP 연결, HTTP 통신 (Naver는 웹이니까), Socket 통신
- Proxy 경우 = PC (3.3.3.3)가 PC2 (9.9.9.9)를 Proxy로 설정을 하면, PC2를 경유해서 Naver로 연결
  - PC2번에서 Proxy 역할을 해줄 수 있는 Process가 있다. 이 Process의 Socket 인터페이스가 2개 있는데, S1은 **Inbound** 정보를 받기만 하고 S2에 보내서 **Outbound** 시킴 (왜 이렇게 하는지는 나중에)
- 암기법 : User mode, Application, Proxy = Socket, Stream, / Inline, Out of path = Packet