# 문제풀이

### 프로그래머스 level 2 ( 두 큐의 합 같게 만들기 )

배열로 큐를 구현하여 시도했더니, 시간 초과가 뜬다. 정직하게 접근하면 최대 30만번을 반복하여 비교하기 때문.

시행 횟수를 줄이기 위해 모든 경우의 수를 비교하지 않고 queue1과 queue2의 총합의 절반만 구한다. queue2는 queue1의 대체 박스와 같은 느낌으로 사용!

while 반복문에서 탈출 조건을 찾는 것이 힘들었다.

보기1을 예시로, 만약 qeueu1 과 queue2의 모든 인덱스를 교체해도 조건에 맞지 않게 된다면 그 경우의 수는 초기 queue 크기의 * 3 을 넘지 않으므로 이 조건을 탈출 조건으로 걸었다.

```jsx
// 다른 나의 풀이
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int solution(int[] queue1, int[] queue2) {
        Queue<Integer> que1 = new LinkedList<>();
        Queue<Integer> que2 = new LinkedList<>();

        long total = 0;
        long sum1 = 0, sum2 = 0;

        for (int i = 0; i < queue1.length; i++) {
            sum1 += queue1[i];
            que1.add(queue1[i]);
        }
        for (int i = 0; i < queue2.length; i++) {
            sum2 += queue2[i];
            que2.add(queue2[i]);
        }
        total = sum1 + sum2;
        if (total % 2 != 0) return -1;
        total /= 2;

        int cnt = 0;

        while (sum1 != total) {
            if (sum1 > total) {
                int tmp = que1.poll();
                sum1 -= tmp;
                sum2 += tmp;
                que2.add(tmp);
                cnt++;
            }
            if (sum1 < total) {
                int tmp = que2.poll();
                sum2 -= tmp;
                sum1 += tmp;
                que1.add(tmp);
                cnt++;
            }
            if (cnt > queue1.length * 3) return -1;
        }
        return cnt;
    }
}
```

### 문자열 압축

```jsx
class Solution {
    public int solution(String s) {
        int answer = s.length();
        // abcabc == 2abc == 4
        //i개 단위로 자르며 반복
        for(int i = 1; i <= s.length() / 2; i++) {
            //타겟 문자 패턴 설정
            String target = s.substring(0, i);
            String cur = ""; //현재 문자열
            int cnt = 1; //압축 카운트
            StringBuilder sb = new StringBuilder();
            System.out.println("바깥 포문 사이클: @@@@" + i);
            System.out.println("1. 타겟 문장: " + target);

            // 1 ~ 6
            for(int j = i; j <= s.length(); j += i) {
                System.out.println("안쪽 포문 사이클: #####" + j);
                //비교할 현재 문자열
                //다음 자를 문자열의 길이가 단위보다 작으면 남은 글자를 저장

                if(j + i >= s.length()) {
                    cur = s.substring(j, s.length());
                    System.out.println("2. j + i > s.length: " + cur); // abc
                }
                else {
                    // abcabc 012345
                    cur = s.substring(j, j + i);
                    System.out.println("3. 현재 : " + cur); // ca

                }

                //문자열이 같으면 압축카운트 증가
                if(cur.equals(target)) {
                    cnt++; // 2
                    System.out.println("4. 타겟 = 현재 = 카운트증가: " + cur); // abc
                }
                //다르면 압축된 문자열을 추가하고 타겟 패턴 변경
                else if(cnt == 1){
                    sb.append(target); // abcabc
                    target = cur; // bc
                    System.out.println("5. 타겟 변경: " + target);
                    System.out.println(sb); // abcabc
                }
                else {
                    sb.append(cnt).append(target); // 2abc
                    target = cur; // abc
                    cnt = 1; // 초기화
                }
                System.out.println("fin. :" + sb); // abc
            }
            //자르고 마지막에 남는 문자열 추가
            if(i != target.length()) {
                sb.append(target);
            }

            answer = Math.min(answer, sb.toString().length());
        }

        return answer;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.solution("ababcdcdababcdcd"));
    }
}
```

### 최소 공배수 구하기

이 문제를 풀기 위해서 찾아본 힌트로 유클리드 호제법이라는 것을 이용하였다.

**유클리드 호제법**이란

두 수 `a, b`가 있을 때 (`a > b`)

`a % b == 0`이면 `b`가 최대공약수이고.

`a % b != 0`이면 (`c = a % b`라고 할 때)

`b % c`를 구해서 `0`이 나올때까지 반복하는 것이다.

처음에는 배열만 갖고 풀이가 안 될 거라고 생각하여 List를 사용해 접근했으나 굳이 그렇게까지 할 필요가 없음을 깨닫고 배열만을 이용하여 풀어보았다.

```java
class Solution {
    public int solution(int[] arr) {
        int answer = arr[0];

        for (int i = 0; i < arr.length; i++) {
            answer = lcm(answer, arr[i]);
        }
        return answer;
    }

    static int gcd(int a, int b) { // 최대공약수
        if (a % b == 0) {
            return b;
        }
        return gcd(b, a % b);
    }

    static int lcm(int a, int b) {  // 최소공배수
        return a * b / gcd(a, b);
    }
}
class Solution {
    public int solution(int[] arr) {
        int answer = arr[0];

        for (int i = 0; i < arr.length; i++) {
            System.out.println("################"+ i);

            int gcd = gcd(answer, arr[i]); // 최대공약수
            System.out.println("1. gcd 값: " + gcd);
            answer = answer * arr[i] / gcd;   // 최소공배수
            System.out.println("2. answer :" + answer);
        }
        return answer;
    }

    public static int gcd(int a, int b) {

        int x = Math.max(a, b);
        int y = Math.min(a, b);
        System.out.println("최대값: " + x + "최소값 : " +  y);

        while (x % y != 0) { // 나머지가 0이 될 때까지
            int r = x % y;
            x = y;
            y = r;
        }
        return y;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] ex = {1, 2, 3, 5};
        sol.solution(ex);
    }
}
```

### 기능개발

진짜 너무 오래 걸렸다. 개발 실력이 부족한데 떠오르는대로 구현하며 어찌저찌 풀긴 풀었다. 엉성한 코드지만, 정말 도움이 많이 된 문제였다.

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Test {
    List<Integer> pro = new LinkedList<>();
    List<Integer> spd = new LinkedList<>();
    List<Integer> ans = new LinkedList<>();

    public List<Integer> solution(int[] progress, int[] speed) {

        List<Integer> answer = new ArrayList<>();

        for (int i = 0; i < progress.length; i++) {
            pro.add(progress[i]);
        }
        for (int i = 0; i < speed.length; i++) {
            spd.add(speed[i]);
        }

        for (int i = 0; i < progress.length; i++) {
            int fm = findMax(pro.get(i), spd.get(i));
            ans.add(fm);
        }
        // 93, 30 , 55
        // 1, 30 , 5
        // 7 , 3, 9   // 5, 10, 1, 1, 20, 1
        int t = 0;
        int count = 1;
        for (int j = 1; j < ans.size(); j++) {
            if (ans.get(t) < ans.get(1)) {
                System.out.println("1j = " + j);
                answer.add(count);
                t = j;
            }
            else if (ans.get(t) >= ans.get(j)) {
                System.out.println("2j = " + j);
                count++;
                System.out.println("count = " + count);
            }
            else if (ans.get(t) < ans.get(j)){
                System.out.println("3j = " + j);
                answer.add(count);
                t = j;
                count = 1;
                System.out.println("count = " + count);;
            }
            if (j == ans.size()-1){
                System.out.println("3j = " + j);
                answer.add(count);
                System.out.println("count = " + count);
                System.out.println(" dho? ");
            }

        }
        System.out.print("answer: ");
        return answer;
    }

    public static int findMax(Integer a, Integer b) {
        System.out.println("a = " + a + ",  b = " + b);

        int cnt = 1;
        int temp = a + b;
        System.out.println("temp = " + temp);
        while (temp < 100) {
            temp = a + b;
            a = temp;
            cnt++;
        }
        System.out.println("cnt :" + cnt);
        return cnt;
    }

    public static void main(String[] args) {
        Test ts = new Test();
        int[] arr1 = {93, 30, 55}; // 7, 3, 9, 4, 6, 4 // 2, 2, 2
        int[] arr2 = {1, 30, 5};
        System.out.println(ts.solution(arr1, arr2));
    }
}
```

### 올바른 괄호

`Stack` 클래스의 존재를 모르고 있어서 `Map, List` 등을 사용해 문제를 풀어보았다. (중복되는 키값 만큼 밸류 값을 증가시키려고)

5번, 11번 테스트 케이스를 풀지 못하였으며, 효율성 테스트도 통과하지 못했다.

내가 보기에도 코드가 필요 이상으로 복잡하게 짜여져 있으며, 효율성이 좋지 못한 코드임을 알 수 있었다.

```java
//승한's 풀이

import java.util.*;

class Solution {
    boolean solution(String s) throws Exception {
        boolean answer = true;

        Map<String, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            map.put(String.valueOf(c), map.getOrDefault(String.valueOf(c), 0));
        }

        for (char c : s.toCharArray()) {
            String str = String.valueOf(c);
            int value = map.get(str);
            map.put(str, value + 1);
        }

        for (String key : map.keySet()) {
            System.out.println("key = " + key + ", value  : " + map.get(key));
        }

        for (String key : map.keySet()) {
            int num = map.get(key);
            int temp = 0;
            if (temp == num) {
                System.out.println(temp +" " + num);
            }
            temp = num;
        }

        if (s.length() % 2 == 1) answer = false;

        return answer;
    }

    public static void main(String[] args) throws Exception {
        String s = "(())";
        Solution sol = new Solution();
        System.out.println(sol.solution(s));

    }
}
//나의 풀이
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    boolean solution(String s) {

        boolean answer = false;
        String[] str = s.split("");

        if (s.length() % 2 == 1) {
            answer = false;
        } else if (rightStart(str)) {

            Map<String, Integer> map = new HashMap<>();

            for (String key : s.split("")) {
                map.put(key, 0);
            }
            for (String key : s.split("")) {
                int value = map.get(key);
                map.put(key, value + 1);
            }

            if (map.get("(") == map.get(")")) {
                answer = true;
            } else {
                answer = false;
            }
        }
        return answer;
    }

    public static boolean rightStart(String[] str) {
        boolean flag = true;
        List<String> list = new ArrayList<>();
        for (int i = 0; i < str.length; i++) {
            list.add(str[i]);
        }
        if (list.get(0).equals(")") || list.get(list.size() - 1).equals("(")) {
            flag = false;
        }
        return flag;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.solution(")(()"));
    }
}
// 올바른 풀이
import java.util.*;

class Solution {
    boolean solution(String s) {
        boolean answer = true;
        Stack<Character> st = new Stack<>();
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i) == '('){
                st.push('(');
            }else{
                if(st.isEmpty()){
                    answer = false;
                    break;
                }else{
                    st.pop();
                }
            }
        }
        if(st.size() > 0)
            return false;

        return answer;
    }
}
```

`'('`가 들어오면 stack에 쌓아주고 `')'`가 들어오면 stack에서 추출한다.

결국 두 괄호의 개수가 같아야만 참이 되므로, `st.size() > 0`이면 false가 되는 것이다.

위와 같은 방식으로 `Stack`을 사용하지 않고도 문제를 풀 수 있다.

```jsx
class Solution {
    boolean solution(String s) {
        boolean answer = false;
        int count = 0;
        for(int i = 0; i<s.length();i++){
            if(s.charAt(i) == '('){
                count++;
            }
            if(s.charAt(i) == ')'){
                count--;
            }
            if(count < 0){
                break;
            }
        }
        if(count == 0){
            answer = true;
        }

        return answer;
    }
}
```

### 124 나라의 숫자

`1, 2, 4`만 사용되고 있으므로 이 규칙을 찾는 것이 중요한 문제였다.

`String[] num` 의 규칙을 찾아낸 후 적용하여 푸는 것이 중요했던 것 같다.

```jsx
class Solution {
    public String solution (int n ) {
        String[] num = {"4", "1", "2"};
        String answer = "";

        while (n > 0) {
            answer = num[n % 3] + answer;
            n = (n - 1) / 3; // 3의 배수의 경우 사이클을 한 번 낮춰주어야 한다.
        }
        return answer;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        System.out.println(sl.solution(4));
    }
}
```

### nQueen

아직 내 수준으로는 이해하기 힘든 난이도의 문제였다. 나중에 좀 더 성장한 후에 다시 문제를 곱씹어 볼 필요가 있다.

```jsx
class Solution{
    public int solution(int n) {
        int answer = 0;
        int[] cols = new int[n];
        answer = backTrack(0, cols, n);

        return answer;
    }

    public int backTrack(int row, int[] cols, int n) {
        int sum = 0;
        if (row == n) {
            return 1;
        } else {
            for (int i = 0; i < n; i++) {
                cols[row] = i;
                if (possible(row, cols)) {
                    sum += backTrack(row + 1, cols, n);
                }
            }
        }
        return sum;
    }

    public boolean possible(int row, int[] cols) {
        for (int i = 0; i < row; i++) {
            if (cols[i] == cols[row] || Math.abs(row - i) == Math.abs(cols[i] - cols[row])) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        System.out.println(sl.solution(4));
    }
}
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

public class Solution {
    /*
     * 문제 설명
     *가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다.
     * 예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다.
     *
     */   //1, 3, 0, 2
//        0,X,0,0 // set = 0,
//        0,0,0,X // if(set.contains(previous) || Math.abs(j - i) == 1 ? continue : set.add(current);
//        X,0,0,0  // temp - 1 < 0 계산 X
//        0,0,X,0 //

    public int solution(int n) {
        int answer = 0;

        int[] temp = new int[n]; // 1,3,0,2 , 2,0,3,1

        for (int i = 0; i < n; i++) {
            int index = 0;
            temp[index] = i;
            answer += isPossible(0, temp, n);
        }
        System.out.println("answer = " + answer);
        return answer;

    }
    // 0, 0, 0, 0
    // temp[0] = 0;
    public int isPossible(int pre, int[] temp, int n) {
        int sum = 0;

        if(pre == n-1){
            return sum;
        }else {
            for (int i = 0; i < temp.length; i++) {
                temp[pre + 1] = i;

                if (temp[pre] != temp[pre+1] && Math.abs(temp[pre] - temp[pre+1]) != 1) {
                    isPossible(pre + 1, temp, n);
                    Set<Integer> set = Arrays.stream(temp).boxed().collect(Collectors.toSet());

                    System.out.println("temp = " + Arrays.toString(temp));
                    System.out.println("set = " + set);
                    if (set.size() == n) {
                        sum ++;
                        return sum;
                    }
                }
            }
        }
        System.out.println("sum = " + sum);
        return sum;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        sol.solution(4);
    }
}
```

### JadenCase

모든 문제에 있어서 List 자료형에 너무 크게 의존하는 버릇이 있는 것 같다.

공백의 개수가 여러 개 나올 수 있다는 점을 유의해서 풀었어야 한다.

```java
// 망한 풀이 접근

import java.text.NumberFormat;
import java.text.ParsePosition;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Solution {
    public void solution(String s) {
        StringBuilder answer = new StringBuilder();
        List<String> list = new ArrayList<>();

        for (String c : s.split(" ")) {
            list.add(c);
        }

        for (int i = 0; i < list.size(); i++) {
            String tmp = list.get(i);
            System.out.println("tmp = " + tmp);
            List<String> temp = new ArrayList<>();
            for (String c : tmp.split("")) {
                temp.add(c);
                System.out.println("temp = " + temp);
            }
            if (isNumberic(temp.get(0))) {
                answer.append(tmp + " ");
            } else {
                tmp = tmp.toLowerCase();
                System.out.println(tmp);
            }

        }
        System.out.println("list = " + list);
        System.out.println("answer = " + answer);
    }

    public static boolean isNumberic(String tmp) {
        ParsePosition pos = new ParsePosition(0);
        NumberFormat.getInstance().parse(tmp, pos);
        return tmp.length() == pos.getIndex();
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        sl.solution("3people unFollowed me");
    }
}
// 올바른 풀이 접근
import java.util.Locale;

class Solution {
    public String solution(String s) {
        String answer = "";

        StringBuffer sb = new StringBuffer();
        s = s.toLowerCase();
        sb.append(Character.toUpperCase(s.charAt(0)));

        // 3pop pc
        for(int i = 1; i < s.length(); i++){
            if(s.charAt(i) == ' '){
                sb.append(" ");
            } else if (s.charAt(i - 1) == ' ') {
                sb.append(Character.toUpperCase(s.charAt(i)));
            }else{
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
```

### 피보나치 수

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public int solution(int n) {
        int answer = 0;

        List<Integer> list = new ArrayList<>();
        list.add(0);
        list.add(1);

        for (int i = 0; i < n; i++) {
            int sum = (list.get(i) % 1234567) + (list.get(i+1) % 1234567);
            list.add(sum);
        }
        answer = list.get(n) % 1234567;
        System.out.println(answer);
        return answer;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        sl.solution(6);

    }
}
// 친구의 풀이
package programmers;

public class Fibonacci {
    public static int solution(int n) {
        int[] arr = new int[n + 1];
        arr[0] = 0;
        arr[1] = 1;

        for (int i = 2; i <= n; i++) {
            arr[i] = (arr[i - 1] + arr[i - 2]) % 1234567;
        }
        return arr[n];
    }
    public static void main(String[] args) {
        System.out.println(solution(1234));
    }
}
```

### 숫자 문자열과 영어 문자열

굳이 `num` 배열을 안 쓰고 인덱스 값으로 찾았어도 괜찮았을 것 같다!

```java
class Solution {
    public int solution(String s) {
        int answer = 0;

        String[] alpha = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
        String[] num = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};

        for (int i = 0; i < alpha.length; i++) {
            if (s.contains(alpha[i])) {
                s = s.replace(alpha[i], num[i]);
                System.out.println("s = " + s);
            }
        }
        answer = Integer.parseInt(s);
        return answer;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        System.out.println(sl.solution("2three45sixseven"));
    }
}
```

### 최솟값 만들기

이번 문제는 비교적 쉬운 문제였다. 최솟값을 만들어주는 조건식을 두 가지로 생각해 볼 수 있었다.

```java
import java.util.*;

class Solution
{
    public int solution(int []A, int []B)
    {
        int answer = 0;
				
				//Collections.reverseOrder()를 쓰기 위해 int[] B를 Integer로 변환
        Integer[] b = new Integer[B.length]; 
        for (int i = 0; i < b.length; i++) {
            b[i] = B[i];
        }

        Arrays.sort(A);
        Arrays.sort(b, Collections.reverseOrder());

        for (int i = 0; i < A.length; i++) {
            answer += A[i] * b[i];
        }

        return answer;
    }
}
class Solution
{
    public int solution(int []A, int []B)
    {
        Arrays.sort(A);
        Arrays.sort(B);

        int length = A.length;
        int answer = 0;

        for (int i = 0; i < length; i++) {
          answer += A[i] * B[length - 1 - i];
        }

        return answer;
    }
```

### 최댓값과 최솟값

바로 이전 문제와 상당히 유사한 문제여서 쉽게 풀 수 있었다.

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

class Solution {
    public String solution(String s) {
        String answer = "";

        List<Integer> list = new ArrayList<>();

        for (String c : s.split(" ")) {
            list.add(Integer.parseInt(c));
        }
        list.sort(Comparator.naturalOrder());

        answer += list.get(0) + " " + list.get(list.size() - 1);
        System.out.println("answer = " + answer);
        
        return answer;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        sl.solution("1 2 3 4");
    }
}
```

### 숫자의 표현

요즘 문제 풀이를 많이 하다보니 자꾸 재귀를 사용해서 문제를 풀려고 하는 습관이 생겨버렸다. 문제를 좀 더 넓은 스펙트럼으로 생각하고 풀 수 있도록 하자.

```java
class Solution {
    public int solution(int n) {
        int answer = 0;

        for (int i = 1; i <= n; i++) {
            int inum = i;
            int add = 0;
            while (true) {
                add += inum;

                if (add == n) {
                    answer++;
                    break;
                } else if (add > n) {
                    break;
                }
                inum++;
            }
        }
        return answer;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        sol.solution(15);

    }
}
```

### 소수 찾기

재귀 함수 `recursive`와 그 안에서의 조건 `others.substring(0, i) + others.substring(i+1)` 을 떠올린 다는 게 너무 어려운 과제였다.

```java
import java.util.HashSet;
import java.util.Iterator;

class Solution {
    HashSet<Integer> numberSet = new HashSet<>();

    public boolean isPrime(int num) {
        // 1. 0과 1은 소수가 아니다.
        if (num == 0 || num == 1) {
            return false;
        }
        // 2. 에라토스테네스의 채의 limit을 계산한다.
        int lim = (int) Math.sqrt(num);

        // 3. limit 까지만 배수의 여부를 확인한다.
        for (int i = 2; i <= lim; i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }

    public void recursive(String comb, String others) {
        // 1. 현재 조합을 set에 추가한다.
        if (!comb.equals("")) {
            numberSet.add(Integer.parseInt(comb));
            System.out.println("numberSet = " + numberSet);
        }
        // 2. 남은 숫자 중 한 개를 더해 새로운 조합을 만든다.
        for (int i = 0; i < others.length(); i++) {
            System.out.println("i = " + i);
            System.out.print("new comb = " + comb + others.charAt(i) + " ");
            System.out.println("new others : " + others.substring(0, i) + others.substring(i+1));
            recursive(comb + others.charAt(i), others.substring(0, i) + others.substring(i + 1));
        }

    }

    public int solution(String numbers) {
        int cnt = 0;
        // 1. 모든 조합의 숫자를 만든다.
        recursive("", numbers);

        System.out.println("numberSet = " + numberSet);

        // 2. 소수의 개수만 센다.
        Iterator<Integer> it = numberSet.iterator(); // 자료 구조에 상관 없이 항상 가능해서
        while (it.hasNext()) {
            int number = it.next();
            if (isPrime(number)) {
                cnt++;
            }
        }
        // 3. 소수의 개수를 반환한다.
        return cnt;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.solution("173"));

    }
}
```

### 이진 변환 반복하기

이번 문제도 굳이 재귀함수를 사용하지 않았어도 될 문제였는데, 아쉽게도 그렇게 풀지를 못하였다. 머리가 자꾸 굳어간다..

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    int count = 0;
    int cycle = 0;

    public int[] solution(String s) {
        int[] answer = new int[2];
        changeN(s);

        answer[0] = cycle;
        answer[1] = count;
        return answer;
    }

    public String changeN(String s) {
        String tmp = "";

        if (s.equals("1")) {
            return tmp;
        }
        cycle++;
        List<String> list = new ArrayList<>();

        for (String c : s.split("")) {
            if (c.equals("0")) {
                count++;
            } else {
                list.add(c);
            }
        }
        tmp = Integer.toBinaryString(list.size());

        changeN(tmp);
        return tmp;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(Arrays.toString(sol.solution("1111111")));
    }
}
```

ㅇ