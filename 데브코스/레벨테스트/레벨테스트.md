# 문제풀이

### 프로그래머스 level 2 ( 두 큐의 합 같게 만들기 )

배열로 큐를 구현하여 시도했더니, 시간 초과가 뜬다. 정직하게 접근하면 최대 30만번을 반복하여 비교하기 때문.

시행 횟수를 줄이기 위해 모든 경우의 수를 비교하지 않고 queue1과 queue2의 총합의 절반만 구한다. queue2는 queue1의 대체 박스와 같은 느낌으로 사용!

while 반복문에서 탈출 조건을 찾는 것이 힘들었다.

보기1을 예시로, 만약 qeueu1 과 queue2의 모든 인덱스를 교체해도 조건에 맞지 않게 된다면 그 경우의 수는 초기 queue 크기의 * 3 을 넘지 않으므로 이 조건을 탈출 조건으로 걸었다.

```jsx
// 다른 나의 풀이
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int solution(int[] queue1, int[] queue2) {
        Queue<Integer> que1 = new LinkedList<>();
        Queue<Integer> que2 = new LinkedList<>();

        long total = 0;
        long sum1 = 0, sum2 = 0;

        for (int i = 0; i < queue1.length; i++) {
            sum1 += queue1[i];
            que1.add(queue1[i]);
        }
        for (int i = 0; i < queue2.length; i++) {
            sum2 += queue2[i];
            que2.add(queue2[i]);
        }
        total = sum1 + sum2;
        if (total % 2 != 0) return -1;
        total /= 2;

        int cnt = 0;

        while (sum1 != total) {
            if (sum1 > total) {
                int tmp = que1.poll();
                sum1 -= tmp;
                sum2 += tmp;
                que2.add(tmp);
                cnt++;
            }
            if (sum1 < total) {
                int tmp = que2.poll();
                sum2 -= tmp;
                sum1 += tmp;
                que1.add(tmp);
                cnt++;
            }
            if (cnt > queue1.length * 3) return -1;
        }
        return cnt;
    }
}
```

### 문자열 압축

```jsx
class Solution {
    public int solution(String s) {
        int answer = s.length();
        // abcabc == 2abc == 4
        //i개 단위로 자르며 반복
        for(int i = 1; i <= s.length() / 2; i++) {
            //타겟 문자 패턴 설정
            String target = s.substring(0, i);
            String cur = ""; //현재 문자열
            int cnt = 1; //압축 카운트
            StringBuilder sb = new StringBuilder();
            System.out.println("바깥 포문 사이클: @@@@" + i);
            System.out.println("1. 타겟 문장: " + target);

            // 1 ~ 6
            for(int j = i; j <= s.length(); j += i) {
                System.out.println("안쪽 포문 사이클: #####" + j);
                //비교할 현재 문자열
                //다음 자를 문자열의 길이가 단위보다 작으면 남은 글자를 저장

                if(j + i >= s.length()) {
                    cur = s.substring(j, s.length());
                    System.out.println("2. j + i > s.length: " + cur); // abc
                }
                else {
                    // abcabc 012345
                    cur = s.substring(j, j + i);
                    System.out.println("3. 현재 : " + cur); // ca

                }

                //문자열이 같으면 압축카운트 증가
                if(cur.equals(target)) {
                    cnt++; // 2
                    System.out.println("4. 타겟 = 현재 = 카운트증가: " + cur); // abc
                }
                //다르면 압축된 문자열을 추가하고 타겟 패턴 변경
                else if(cnt == 1){
                    sb.append(target); // abcabc
                    target = cur; // bc
                    System.out.println("5. 타겟 변경: " + target);
                    System.out.println(sb); // abcabc
                }
                else {
                    sb.append(cnt).append(target); // 2abc
                    target = cur; // abc
                    cnt = 1; // 초기화
                }
                System.out.println("fin. :" + sb); // abc
            }
            //자르고 마지막에 남는 문자열 추가
            if(i != target.length()) {
                sb.append(target);
            }

            answer = Math.min(answer, sb.toString().length());
        }

        return answer;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.solution("ababcdcdababcdcd"));
    }
}
```

### 최소 공배수 구하기

이 문제를 풀기 위해서 찾아본 힌트로 유클리드 호제법이라는 것을 이용하였다.

**유클리드 호제법**이란

두 수 `a, b`가 있을 때 (`a > b`)

`a % b == 0`이면 `b`가 최대공약수이고.

`a % b != 0`이면 (`c = a % b`라고 할 때)

`b % c`를 구해서 `0`이 나올때까지 반복하는 것이다.

처음에는 배열만 갖고 풀이가 안 될 거라고 생각하여 List를 사용해 접근했으나 굳이 그렇게까지 할 필요가 없음을 깨닫고 배열만을 이용하여 풀어보았다.

```java
class Solution {
    public int solution(int[] arr) {
        int answer = arr[0];

        for (int i = 0; i < arr.length; i++) {
            answer = lcm(answer, arr[i]);
        }
        return answer;
    }

    static int gcd(int a, int b) { // 최대공약수
        if (a % b == 0) {
            return b;
        }
        return gcd(b, a % b);
    }

    static int lcm(int a, int b) {  // 최소공배수
        return a * b / gcd(a, b);
    }
}
class Solution {
    public int solution(int[] arr) {
        int answer = arr[0];

        for (int i = 0; i < arr.length; i++) {
            System.out.println("################"+ i);

            int gcd = gcd(answer, arr[i]); // 최대공약수
            System.out.println("1. gcd 값: " + gcd);
            answer = answer * arr[i] / gcd;   // 최소공배수
            System.out.println("2. answer :" + answer);
        }
        return answer;
    }

    public static int gcd(int a, int b) {

        int x = Math.max(a, b);
        int y = Math.min(a, b);
        System.out.println("최대값: " + x + "최소값 : " +  y);

        while (x % y != 0) { // 나머지가 0이 될 때까지
            int r = x % y;
            x = y;
            y = r;
        }
        return y;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] ex = {1, 2, 3, 5};
        sol.solution(ex);
    }
}
```

### 기능개발

진짜 너무 오래 걸렸다. 개발 실력이 부족한데 떠오르는대로 구현하며 어찌저찌 풀긴 풀었다. 엉성한 코드지만, 정말 도움이 많이 된 문제였다.

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Test {
    List<Integer> pro = new LinkedList<>();
    List<Integer> spd = new LinkedList<>();
    List<Integer> ans = new LinkedList<>();

    public List<Integer> solution(int[] progress, int[] speed) {

        List<Integer> answer = new ArrayList<>();

        for (int i = 0; i < progress.length; i++) {
            pro.add(progress[i]);
        }
        for (int i = 0; i < speed.length; i++) {
            spd.add(speed[i]);
        }

        for (int i = 0; i < progress.length; i++) {
            int fm = findMax(pro.get(i), spd.get(i));
            ans.add(fm);
        }
        // 93, 30 , 55
        // 1, 30 , 5
        // 7 , 3, 9   // 5, 10, 1, 1, 20, 1
        int t = 0;
        int count = 1;
        for (int j = 1; j < ans.size(); j++) {
            if (ans.get(t) < ans.get(1)) {
                System.out.println("1j = " + j);
                answer.add(count);
                t = j;
            }
            else if (ans.get(t) >= ans.get(j)) {
                System.out.println("2j = " + j);
                count++;
                System.out.println("count = " + count);
            }
            else if (ans.get(t) < ans.get(j)){
                System.out.println("3j = " + j);
                answer.add(count);
                t = j;
                count = 1;
                System.out.println("count = " + count);;
            }
            if (j == ans.size()-1){
                System.out.println("3j = " + j);
                answer.add(count);
                System.out.println("count = " + count);
                System.out.println(" dho? ");
            }

        }
        System.out.print("answer: ");
        return answer;
    }

    public static int findMax(Integer a, Integer b) {
        System.out.println("a = " + a + ",  b = " + b);

        int cnt = 1;
        int temp = a + b;
        System.out.println("temp = " + temp);
        while (temp < 100) {
            temp = a + b;
            a = temp;
            cnt++;
        }
        System.out.println("cnt :" + cnt);
        return cnt;
    }

    public static void main(String[] args) {
        Test ts = new Test();
        int[] arr1 = {93, 30, 55}; // 7, 3, 9, 4, 6, 4 // 2, 2, 2
        int[] arr2 = {1, 30, 5};
        System.out.println(ts.solution(arr1, arr2));
    }
}
```

### 올바른 괄호

`Stack` 클래스의 존재를 모르고 있어서 `Map, List` 등을 사용해 문제를 풀어보았다. (중복되는 키값 만큼 밸류 값을 증가시키려고)

5번, 11번 테스트 케이스를 풀지 못하였으며, 효율성 테스트도 통과하지 못했다.

내가 보기에도 코드가 필요 이상으로 복잡하게 짜여져 있으며, 효율성이 좋지 못한 코드임을 알 수 있었다.

```java
//승한's 풀이

import java.util.*;

class Solution {
    boolean solution(String s) throws Exception {
        boolean answer = true;

        Map<String, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            map.put(String.valueOf(c), map.getOrDefault(String.valueOf(c), 0));
        }

        for (char c : s.toCharArray()) {
            String str = String.valueOf(c);
            int value = map.get(str);
            map.put(str, value + 1);
        }

        for (String key : map.keySet()) {
            System.out.println("key = " + key + ", value  : " + map.get(key));
        }

        for (String key : map.keySet()) {
            int num = map.get(key);
            int temp = 0;
            if (temp == num) {
                System.out.println(temp +" " + num);
            }
            temp = num;
        }

        if (s.length() % 2 == 1) answer = false;

        return answer;
    }

    public static void main(String[] args) throws Exception {
        String s = "(())";
        Solution sol = new Solution();
        System.out.println(sol.solution(s));

    }
}
//나의 풀이
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    boolean solution(String s) {

        boolean answer = false;
        String[] str = s.split("");

        if (s.length() % 2 == 1) {
            answer = false;
        } else if (rightStart(str)) {

            Map<String, Integer> map = new HashMap<>();

            for (String key : s.split("")) {
                map.put(key, 0);
            }
            for (String key : s.split("")) {
                int value = map.get(key);
                map.put(key, value + 1);
            }

            if (map.get("(") == map.get(")")) {
                answer = true;
            } else {
                answer = false;
            }
        }
        return answer;
    }

    public static boolean rightStart(String[] str) {
        boolean flag = true;
        List<String> list = new ArrayList<>();
        for (int i = 0; i < str.length; i++) {
            list.add(str[i]);
        }
        if (list.get(0).equals(")") || list.get(list.size() - 1).equals("(")) {
            flag = false;
        }
        return flag;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.solution(")(()"));
    }
}
// 올바른 풀이
import java.util.*;

class Solution {
    boolean solution(String s) {
        boolean answer = true;
        Stack<Character> st = new Stack<>();
        for(int i=0; i<s.length(); i++){
            if(s.charAt(i) == '('){
                st.push('(');
            }else{
                if(st.isEmpty()){
                    answer = false;
                    break;
                }else{
                    st.pop();
                }
            }
        }
        if(st.size() > 0)
            return false;

        return answer;
    }
}
```

`'('`가 들어오면 stack에 쌓아주고 `')'`가 들어오면 stack에서 추출한다.

결국 두 괄호의 개수가 같아야만 참이 되므로, `st.size() > 0`이면 false가 되는 것이다.

위와 같은 방식으로 `Stack`을 사용하지 않고도 문제를 풀 수 있다.

```jsx
class Solution {
    boolean solution(String s) {
        boolean answer = false;
        int count = 0;
        for(int i = 0; i<s.length();i++){
            if(s.charAt(i) == '('){
                count++;
            }
            if(s.charAt(i) == ')'){
                count--;
            }
            if(count < 0){
                break;
            }
        }
        if(count == 0){
            answer = true;
        }

        return answer;
    }
}
```

### 124 나라의 숫자

`1, 2, 4`만 사용되고 있으므로 이 규칙을 찾는 것이 중요한 문제였다.

`String[] num` 의 규칙을 찾아낸 후 적용하여 푸는 것이 중요했던 것 같다.

```jsx
class Solution {
    public String solution (int n ) {
        String[] num = {"4", "1", "2"};
        String answer = "";

        while (n > 0) {
            answer = num[n % 3] + answer;
            n = (n - 1) / 3; // 3의 배수의 경우 사이클을 한 번 낮춰주어야 한다.
        }
        return answer;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        System.out.println(sl.solution(4));
    }
}
```

### nQueen

아직 내 수준으로는 이해하기 힘든 난이도의 문제였다. 나중에 좀 더 성장한 후에 다시 문제를 곱씹어 볼 필요가 있다.

```jsx
class Solution{
    public int solution(int n) {
        int answer = 0;
        int[] cols = new int[n];
        answer = backTrack(0, cols, n);

        return answer;
    }

    public int backTrack(int row, int[] cols, int n) {
        int sum = 0;
        if (row == n) {
            return 1;
        } else {
            for (int i = 0; i < n; i++) {
                cols[row] = i;
                if (possible(row, cols)) {
                    sum += backTrack(row + 1, cols, n);
                }
            }
        }
        return sum;
    }

    public boolean possible(int row, int[] cols) {
        for (int i = 0; i < row; i++) {
            if (cols[i] == cols[row] || Math.abs(row - i) == Math.abs(cols[i] - cols[row])) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        System.out.println(sl.solution(4));
    }
}
```

### JadenCase

모든 문제에 있어서 List 자료형에 너무 크게 의존하는 버릇이 있는 것 같다.

공백의 개수가 여러 개 나올 수 있다는 점을 유의해서 풀었어야 한다.

```java
// 망한 풀이 접근

import java.text.NumberFormat;
import java.text.ParsePosition;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Solution {
    public void solution(String s) {
        StringBuilder answer = new StringBuilder();
        List<String> list = new ArrayList<>();

        for (String c : s.split(" ")) {
            list.add(c);
        }

        for (int i = 0; i < list.size(); i++) {
            String tmp = list.get(i);
            System.out.println("tmp = " + tmp);
            List<String> temp = new ArrayList<>();
            for (String c : tmp.split("")) {
                temp.add(c);
                System.out.println("temp = " + temp);
            }
            if (isNumberic(temp.get(0))) {
                answer.append(tmp + " ");
            } else {
                tmp = tmp.toLowerCase();
                System.out.println(tmp);
            }

        }
        System.out.println("list = " + list);
        System.out.println("answer = " + answer);
    }

    public static boolean isNumberic(String tmp) {
        ParsePosition pos = new ParsePosition(0);
        NumberFormat.getInstance().parse(tmp, pos);
        return tmp.length() == pos.getIndex();
    }

    public static void main(String[] args) {
        Solution sl = new Solution();
        sl.solution("3people unFollowed me");
    }
}
// 올바른 풀이 접근
import java.util.Locale;

class Solution {
    public String solution(String s) {
        String answer = "";

        StringBuffer sb = new StringBuffer();
        s = s.toLowerCase();
        sb.append(Character.toUpperCase(s.charAt(0)));

        // 3pop pc
        for(int i = 1; i < s.length(); i++){
            if(s.charAt(i) == ' '){
                sb.append(" ");
            } else if (s.charAt(i - 1) == ' ') {
                sb.append(Character.toUpperCase(s.charAt(i)));
            }else{
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
```

ㅇ
