# 문제풀이

### 프로그래머스 level 2 ( 두 큐의 합 같게 만들기 )

배열로 큐를 구현하여 시도했더니, 시간 초과가 뜬다. 정직하게 접근하면 최대 30만번을 반복하여 비교하기 때문.

시행 횟수를 줄이기 위해 모든 경우의 수를 비교하지 않고 queue1과 queue2의 총합의 절반만 구한다. queue2는 queue1의 대체 박스와 같은 느낌으로 사용!

while 반복문에서 탈출 조건을 찾는 것이 힘들었다.

보기1을 예시로, 만약 qeueu1 과 queue2의 모든 인덱스를 교체해도 조건에 맞지 않게 된다면 그 경우의 수는 초기 queue 크기의 * 3 을 넘지 않으므로 이 조건을 탈출 조건으로 걸었다.

```jsx
// 다른 나의 풀이
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int solution(int[] queue1, int[] queue2) {
        Queue<Integer> que1 = new LinkedList<>();
        Queue<Integer> que2 = new LinkedList<>();

        long total = 0;
        long sum1 = 0, sum2 = 0;

        for (int i = 0; i < queue1.length; i++) {
            sum1 += queue1[i];
            que1.add(queue1[i]);
        }
        for (int i = 0; i < queue2.length; i++) {
            sum2 += queue2[i];
            que2.add(queue2[i]);
        }
        total = sum1 + sum2;
        if (total % 2 != 0) return -1;
        total /= 2;

        int cnt = 0;

        while (sum1 != total) {
            if (sum1 > total) {
                int tmp = que1.poll();
                sum1 -= tmp;
                sum2 += tmp;
                que2.add(tmp);
                cnt++;
            }
            if (sum1 < total) {
                int tmp = que2.poll();
                sum2 -= tmp;
                sum1 += tmp;
                que1.add(tmp);
                cnt++;
            }
            if (cnt > queue1.length * 3) return -1;
        }
        return cnt;
    }
}
```

### 문자열 압축

```jsx
class Solution {
    public int solution(String s) {
        int answer = s.length();
        // abcabc == 2abc == 4
        //i개 단위로 자르며 반복
        for(int i = 1; i <= s.length() / 2; i++) {
            //타겟 문자 패턴 설정
            String target = s.substring(0, i);
            String cur = ""; //현재 문자열
            int cnt = 1; //압축 카운트
            StringBuilder sb = new StringBuilder();
            System.out.println("바깥 포문 사이클: @@@@" + i);
            System.out.println("1. 타겟 문장: " + target);

            // 1 ~ 6
            for(int j = i; j <= s.length(); j += i) {
                System.out.println("안쪽 포문 사이클: #####" + j);
                //비교할 현재 문자열
                //다음 자를 문자열의 길이가 단위보다 작으면 남은 글자를 저장

                if(j + i >= s.length()) {
                    cur = s.substring(j, s.length());
                    System.out.println("2. j + i > s.length: " + cur); // abc
                }
                else {
                    // abcabc 012345
                    cur = s.substring(j, j + i);
                    System.out.println("3. 현재 : " + cur); // ca

                }

                //문자열이 같으면 압축카운트 증가
                if(cur.equals(target)) {
                    cnt++; // 2
                    System.out.println("4. 타겟 = 현재 = 카운트증가: " + cur); // abc
                }
                //다르면 압축된 문자열을 추가하고 타겟 패턴 변경
                else if(cnt == 1){
                    sb.append(target); // abcabc
                    target = cur; // bc
                    System.out.println("5. 타겟 변경: " + target);
                    System.out.println(sb); // abcabc
                }
                else {
                    sb.append(cnt).append(target); // 2abc
                    target = cur; // abc
                    cnt = 1; // 초기화
                }
                System.out.println("fin. :" + sb); // abc
            }
            //자르고 마지막에 남는 문자열 추가
            if(i != target.length()) {
                sb.append(target);
            }

            answer = Math.min(answer, sb.toString().length());
        }

        return answer;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.solution("ababcdcdababcdcd"));
    }
}
```

### 최소 공배수 구하기

이 문제를 풀기 위해서 찾아본 힌트로 유클리드 호제법이라는 것을 이용하였다.

**유클리드 호제법**이란

두 수 `a, b`가 있을 때 (`a > b`)

`a % b == 0`이면 `b`가 최대공약수이고.

`a % b != 0`이면 (`c = a % b`라고 할 때)

`b % c`를 구해서 `0`이 나올때까지 반복하는 것이다.

처음에는 배열만 갖고 풀이가 안 될 거라고 생각하여 List를 사용해 접근했으나 굳이 그렇게까지 할 필요가 없음을 깨닫고 배열만을 이용하여 풀어보았다.

```java
class Solution {
    public int solution(int[] arr) {
        int answer = arr[0];

        for (int i = 0; i < arr.length; i++) {
            answer = lcm(answer, arr[i]);
        }
        return answer;
    }

    static int gcd(int a, int b) { // 최대공약수
        if (a % b == 0) {
            return b;
        }
        return gcd(b, a % b);
    }

    static int lcm(int a, int b) {  // 최소공배수
        return a * b / gcd(a, b);
    }
}
class Solution {
    public int solution(int[] arr) {
        int answer = arr[0];

        for (int i = 0; i < arr.length; i++) {
            System.out.println("################"+ i);

            int gcd = gcd(answer, arr[i]); // 최대공약수
            System.out.println("1. gcd 값: " + gcd);
            answer = answer * arr[i] / gcd;   // 최소공배수
            System.out.println("2. answer :" + answer);
        }
        return answer;
    }

    public static int gcd(int a, int b) {

        int x = Math.max(a, b);
        int y = Math.min(a, b);
        System.out.println("최대값: " + x + "최소값 : " +  y);

        while (x % y != 0) { // 나머지가 0이 될 때까지
            int r = x % y;
            x = y;
            y = r;
        }
        return y;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] ex = {1, 2, 3, 5};
        sol.solution(ex);
    }
}
```

### 기능개발

진짜 너무 오래 걸렸다. 개발 실력이 부족한데 떠오르는대로 구현하며 어찌저찌 풀긴 풀었다. 엉성한 코드지만, 정말 도움이 많이 된 문제였다.

```jsx
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

class Test {
    List<Integer> pro = new LinkedList<>();
    List<Integer> spd = new LinkedList<>();
    List<Integer> ans = new LinkedList<>();

    public List<Integer> solution(int[] progress, int[] speed) {

        List<Integer> answer = new ArrayList<>();

        for (int i = 0; i < progress.length; i++) {
            pro.add(progress[i]);
        }
        for (int i = 0; i < speed.length; i++) {
            spd.add(speed[i]);
        }

        for (int i = 0; i < progress.length; i++) {
            int fm = findMax(pro.get(i), spd.get(i));
            ans.add(fm);
        }
        // 93, 30 , 55
        // 1, 30 , 5
        // 7 , 3, 9   // 5, 10, 1, 1, 20, 1
        int t = 0;
        int count = 1;
        for (int j = 1; j < ans.size(); j++) {
            if (ans.get(t) < ans.get(1)) {
                System.out.println("1j = " + j);
                answer.add(count);
                t = j;
            }
            else if (ans.get(t) >= ans.get(j)) {
                System.out.println("2j = " + j);
                count++;
                System.out.println("count = " + count);
            }
            else if (ans.get(t) < ans.get(j)){
                System.out.println("3j = " + j);
                answer.add(count);
                t = j;
                count = 1;
                System.out.println("count = " + count);;
            }
            if (j == ans.size()-1){
                System.out.println("3j = " + j);
                answer.add(count);
                System.out.println("count = " + count);
                System.out.println(" dho? ");
            }

        }
        System.out.print("answer: ");
        return answer;
    }

    public static int findMax(Integer a, Integer b) {
        System.out.println("a = " + a + ",  b = " + b);

        int cnt = 1;
        int temp = a + b;
        System.out.println("temp = " + temp);
        while (temp < 100) {
            temp = a + b;
            a = temp;
            cnt++;
        }
        System.out.println("cnt :" + cnt);
        return cnt;
    }

    public static void main(String[] args) {
        Test ts = new Test();
        int[] arr1 = {93, 30, 55}; // 7, 3, 9, 4, 6, 4 // 2, 2, 2
        int[] arr2 = {1, 30, 5};
        System.out.println(ts.solution(arr1, arr2));
    }
}
```

ㅇ