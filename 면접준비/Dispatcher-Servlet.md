# Dispatcher-Servlet

------

https://mangkyu.tistory.com/18

## Dispatcher-Servlet 이란?

디스패처 서블릿의 dispatch는 “보내다”라는 뜻을 가지고 있다. 그리고 이러한 단어를 포함하는 디스패처 서블릿은 **HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러 라고 정의할 수 있다.**

이것을 보다 자세히 설명하자면, 클라이언트로부터 어떠한 요청이 오면 Tomcato과 같은 서블릿 컨테이너(WAS)가 요청을 받게 된다. 그리고 이 모든 요청을 프론트 컨트롤러인 디스패처 서블릿이 가장 먼저 받게 된다. 그러면 디스패처 서블릿은 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 위임한다.

여기서 Front Controller 라는 용어가 사용되는, 프론트 컨트롤러는 주로 서블릿 컨테이너의 제일 앞에서 서버로 들어오는 클라이언트의 모든 요청을 받아서 처리해주는 컨트롤러로써, MVC 구조에서 함께 사용되는 디자인 패턴이다

## 장점

Spring MVC는 DispathcerServlet이 등장함에 따라 web.xml의 역할을 상당히 축소시켜 주었다. 과거에는 모든 서블릿을 URL 매핑을 위해 web.xml에 모두 등록해주어야 했지만, **디스패처 서블릿이 해당 애플리케이션으로 들어오는 모든 요청을 핸들링해주고, 공통 작업을 처리**하면서 상당히 편리하게 이용할 수 있게 되었다.

## 정적 자원 처리

디스패처 서블릿이 요청을 컨트롤러로 넘겨주는 방식은 효율적으로 보인다. 하지만 디스패처 서블릿이 모든 요청을 처리하다보니 이미지나 HTML/CSS/JavaScript 등과 같은 정적 파일에 대한 요청마저 모두 가로채는 까닭에 정적자원을 불러오지 못하는 상황도 발생하곤 했다. 이러한 문제를 해결하기 위해 개발자들은 2가지 방법을 고안했다.

### 1. 정적 자원 요청과 애플리케이션 요청을 분리

이에 대한 해결책은 두 가지가 있는데, 첫 번째로는 클라이언트의 요청을 두 가지로 분리하여 구분하는 것이다.

- /apps의 URL로 접근하면 디스패처 서블릿이 담당한다
- /resources의 URL로 접근하면 디스패처 서블릿이 담당하지 않는다

이러한 방식은 상당히 코드가 지저분해지며, 모든 요청에 대해서 저런 URL을 붙여주어야 하므로 직관적인 설계가 될 수 없다. 그래서 이러한 방법의 한계를 느끼고 다음의 방법으로 처리를 하게 되었다

### 2. 애플리케이션 요청을 탐색하고 없으면 정적 자원 요청으로 처리

두 번째 방법은 디스패처 서블릿이 요청을 처리한 컨트롤러를 먼저 찾고, 요청에 대한 컨트롤러를 찾을 수 없는 경우에, 2차적으로 설정된 자원 경로를 탐색하여 자원을 탐색. 이렇게 영역을 분리하면 효율적인 리소스 관리를 지원할 뿐 아니라 추후에 확장을 용이하게 해준다는 장점이 있다.

## 디스패처 서블릿의 동작 과정

앞서 설명한대로 디스패처 서블릿은 적합한 컨트롤러와 메서드를 찾아 요청을 위임해야 한다. Dispatcher Servlet의 처리 과정을 살펴보면 다음과 같다

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bImFbg/btrGzZMTuu2/CkY4MiKvl5ivUJPoc5I3zk/img.png

1. 클라이언트의 요청을 디스패처가 받음
2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음
3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달
4. 핸들러 어댑터가 컨트롤러로 요청을 위임
5. 비지니스 로직을 처리
6. 컨트롤러가 값을 반환
7. 핸들러 어댑터가 반환값을 처리
8. 서버의 응답을 클라이언트로 반환