# 컬렉션 프레임워크

------

## 컬렉션 프레임워크란?

배열을 사용하다 보면 여러가지 비효율적인 문제가 생긴다. 가장 큰 문제점은 크기가 고정적이라는 것이다. 배열의 크기는 생성할 때 결정되며 그 크기를 넘어가게 되면 더 이상 데이터를 저장할 수 없다. 또 데이터를 삭제하면 해당 인덱스의 데이터는 비어있어 메모리가 낭비되는 등 여러 문제점들이 발생한다. 그렇기에 자바는 배열의 이러한 문제점을 해결하기 위해, 널리 알려져 있는 자료구조를 바탕으로 객체나 데이터들을 효율적으로 관리(추가, 삭제, 검색, 저장)을 할 수 있는 자료구조들을 만들어 놓았다. 이러한 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 한다. 대표적으로 List, Set, Map, Stack, Queue 등이 있다.

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bdy438/btqEjPZKIY0/e5Wm8ZJmdRNza4tKBzaK6k/img.png

## List 컬렉션

컬렉션 프레임워크를 상속받고 있는 List 컬렉션은 객체를 일려로 늘어놓은 구조를 가지고 있다. List 컬렉션은 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고, 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다. (**인덱스에는 데이터가 저장되어 있는 참조 값을 가지고 있다.)**

List 컬렉션은 객체 자체를 저장하는 것이 아니라 위와 같이 객체의 주소를 참조한다. 동일한 객체를 중복 저장할 수 있는데 이 경우 동일한 주소가 참조된다. null도 저장이 가능한데 이 경우 해당 인덱스는 객체를 참조하지 않는다. List 컬렉션을 구현하는 대표적인 클래스들은 ArrayList, LinkedList, Vector가 있으며, 이 3가지 클래스는 List 인터페이스를 같이 상속하고 있으므로 공통적으로 사용할 수 있는 메서드들이 많다. 기본적인 List 클래스의 주요 메서드는 다음과 같다.

| 메서드                         | 설명                                                  |
| ------------------------------ | ----------------------------------------------------- |
| boolean add(E e)               | 주어진 객체를 맨 끝에 추가합니다.                     |
| void add(int index, E element) | 주어진 인덱스에 객체를 추가합니다.                    |
| set(int index, E element)      | 주어진 인덱스에 저장된 객체를 주어진 객체로 바꿉니다. |
| boolean contains(Object o)     | 주어진 객체가 있는지에 대한 여부를 검색합니다.        |
| E get(int index)               | 주어진 인덱스에 저장된 객체를 리턴합니다.             |
| isEmpty()                      | 컬렉션이 비어있는지 여부를 확인합니다.                |
| int size()                     | 저장되어 있는 전체 객체 수를 리턴합니다.              |
| E remove(int index)            | 주어진 인덱스에 저장된 객체를 삭제합니다.             |
| void clear()                   | 주어진 인덱스에 저장된 객체를 삭제합니다.             |
| boolean remove(Object o)       | 주어진 객체를 삭제합니다.                             |

### ArraysList란?

List 인터페이스를 상속받은 클래스로 크기가 가변적으로 변하는 선형리스트입니다. 일반적인 배열과 같은 순차리스트이며, 인덱스로 내부의 객체를 관리한다는 점 등이 유사하지만, 한 번 생성되면 크기가 변하지 않는 배열과는 달리 ArraysList는 객체들이 추가되어 저장 용량을 초과한다면 자동으로 부족한 크기만큼 저장 용량이 늘어난다는 특징을 가지고 있다.

```java
ArrayList list = new ArrayList();//타입 미설정 Object로 선언된다.
ArrayList<Student> members = new ArrayList<Student>();//타입설정 Student객체만 사용가능
ArrayList<Integer> num = new ArrayList<Integer>();//타입설정 int타입만 사용가능
ArrayList<Integer> num2 = new ArrayList<>();//new에서 타입 파라미터 생략가능
ArrayList<Integer> num3 = new ArrayList<Integer>(10);//초기 용량(capacity)지정
ArrayList<Integer> list2 = new ArrayList<Integer>(Arrays.asList(1,2,3));//생성시 값추가
```

JDK 5.0 이후부터 타입을 명시할 때 자료의 안정성을 위해 Generics라는 개념이 도입되었다. 제네릭스에는 원시 자료형을 객체화 시킨 wrapper 클래스만 사용이 가능하다.

[Wrapper Class](https://www.notion.so/Wrapper-Class-cca0644e9a66497e9a41fab19ede4964)

ㅇ