# 컬렉션 프레임워크

------

https://coding-factory.tistory.com/550

## 컬렉션 프레임워크란?

배열을 사용하다 보면 여러가지 비효율적인 문제가 생긴다. 가장 큰 문제점은 크기가 고정적이라는 것이다. 배열의 크기는 생성할 때 결정되며 그 크기를 넘어가게 되면 더 이상 데이터를 저장할 수 없다. 또 데이터를 삭제하면 해당 인덱스의 데이터는 비어있어 메모리가 낭비되는 등 여러 문제점들이 발생한다. 그렇기에 자바는 배열의 이러한 문제점을 해결하기 위해, 널리 알려져 있는 자료구조를 바탕으로 객체나 데이터들을 효율적으로 관리(추가, 삭제, 검색, 저장)을 할 수 있는 자료구조들을 만들어 놓았다. 이러한 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 한다. 대표적으로 List, Set, Map, Stack, Queue 등이 있다.

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bdy438/btqEjPZKIY0/e5Wm8ZJmdRNza4tKBzaK6k/img.png

## List 컬렉션

컬렉션 프레임워크를 상속받고 있는 List 컬렉션은 객체를 일려로 늘어놓은 구조를 가지고 있다. List 컬렉션은 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고, 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다. (**인덱스에는 데이터가 저장되어 있는 참조 값을 가지고 있다.)**

List 컬렉션은 객체 자체를 저장하는 것이 아니라 위와 같이 객체의 주소를 참조한다. 동일한 객체를 중복 저장할 수 있는데 이 경우 동일한 주소가 참조된다. null도 저장이 가능한데 이 경우 해당 인덱스는 객체를 참조하지 않는다. List 컬렉션을 구현하는 대표적인 클래스들은 ArrayList, LinkedList, Vector가 있으며, 이 3가지 클래스는 List 인터페이스를 같이 상속하고 있으므로 공통적으로 사용할 수 있는 메서드들이 많다. 기본적인 List 클래스의 주요 메서드는 다음과 같다.

| 메서드                         | 설명                                                  |
| ------------------------------ | ----------------------------------------------------- |
| boolean add(E e)               | 주어진 객체를 맨 끝에 추가합니다.                     |
| void add(int index, E element) | 주어진 인덱스에 객체를 추가합니다.                    |
| set(int index, E element)      | 주어진 인덱스에 저장된 객체를 주어진 객체로 바꿉니다. |
| boolean contains(Object o)     | 주어진 객체가 있는지에 대한 여부를 검색합니다.        |
| E get(int index)               | 주어진 인덱스에 저장된 객체를 리턴합니다.             |
| isEmpty()                      | 컬렉션이 비어있는지 여부를 확인합니다.                |
| int size()                     | 저장되어 있는 전체 객체 수를 리턴합니다.              |
| E remove(int index)            | 주어진 인덱스에 저장된 객체를 삭제합니다.             |
| void clear()                   | 주어진 인덱스에 저장된 객체를 삭제합니다.             |
| boolean remove(Object o)       | 주어진 객체를 삭제합니다.                             |

### ArraysList란?

List 인터페이스를 상속받은 클래스로 크기가 가변적으로 변하는 선형리스트입니다. 일반적인 배열과 같은 순차리스트이며, 인덱스로 내부의 객체를 관리한다는 점 등이 유사하지만, 한 번 생성되면 크기가 변하지 않는 배열과는 달리 ArraysList는 객체들이 추가되어 저장 용량을 초과한다면 자동으로 부족한 크기만큼 저장 용량이 늘어난다는 특징을 가지고 있다.

```java
ArrayList list = new ArrayList();//타입 미설정 Object로 선언된다.
ArrayList<Student> members = new ArrayList<Student>();//타입설정 Student객체만 사용가능
ArrayList<Integer> num = new ArrayList<Integer>();//타입설정 int타입만 사용가능
ArrayList<Integer> num2 = new ArrayList<>();//new에서 타입 파라미터 생략가능
ArrayList<Integer> num3 = new ArrayList<Integer>(10);//초기 용량(capacity)지정
ArrayList<Integer> list2 = new ArrayList<Integer>(Arrays.asList(1,2,3));//생성시 값추가
```

JDK 5.0 이후부터 타입을 명시할 때 자료의 안정성을 위해 Generics라는 개념이 도입되었다. 제네릭스에는 원시 자료형을 객체화 시킨 wrapper 클래스만 사용이 가능하다.

[Wrapper Class ( 래퍼 클래스 )](https://www.notion.so/Wrapper-Class-cca0644e9a66497e9a41fab19ede4964)

### LinkedList란?

각 노드가 **데이터와 포인터**를 가지고 한 줄로 연결되어 있는 방식의 자료구조이다. 데이터를 담고 있는 노드들이 연결 되어 있고, 노드의 포인터가 이전 노드와 다음 노드와의 연결을 담당합니다. Node는 **LinkedList에 객체를 추가하거나 삭제하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않습니다**. 중간에 데이터를 추가나 삭제하더라도 전체의 인덱스가 한 칸씩 뒤로 밀리거나 당겨지는 일이 없기에 ArrayList에 비해서 데이터의 추가나 삭제가 용히나, **인덱스가 없기에 특정 요소에 접근하기 위해서는 순차 탐색이 필요로 하여** 탐색 속도가 떨어진다는 단점이 있다. 그러므로 탐색 또는 정렬을 자주 하는 경우엔 배열을 사용하고 데이터의 추가/삭제가 많은 경우 연결 리스트를 사용하는 것이 좋다.

### LinkedList 값 추가

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/bMDHqL/btqEjCtIRbt/NMvN6OfM0Vr5HxiqUMDoF0/img.png

LinkedList의 값이 추가되는 방식은 위의 그림과 같다. 먼저 인자로 받은 값을 가지고 Node를 생성하여 추가한다. 추가된 노드의 이전 노드는 추가된 노드를 가리키고, 추가된 노드는 그다음 노드를 가리키게 된다.

### Vector란?

Vector는 ArrayList와 동일한 내부구조를 가지고 있다. ArrayList와 마찬가지로 Vector 내부에 값이 추가되면 자동으로 크기가 조절되며 그 다음 객체들은 한 자리씩 뒤로 이동한다. Vector는 한 가지 다른 점이 있는데, **동기화된 메서드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메서드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있다.** 그래서 멀티 스레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있다.

## Set 컬렉션

앞서 살펴본 List 컬렉션은 선형구조를 가지고 있으므로 추가한 순서대로 저장이 되어 순서를 유지하였지만, Set 컬렉션의 경우에는 저장 순서가 유지되지 않는다. 그렇기에 Set 컬렉션은 순서 자체가 없으므로 인덱스로 객체를 검색해서 가져오는 get() 메서드도 존재하지 않는다. 대신 전체 객체를 대상으로 한 번씩 반복해서 가져오는 반복자(iterator)를 제공한다.

Set은 비선형 구조이기에 순서가 없고 인덱스가 없다. 그렇기에 값을 추가, 삭제할 시 값을 set 내부에서 검색 한 뒤 추가, 삭제를 진행하기에 List 구조에 비해 속도가 느리다

> 순서 저장을 위해서는 JDK 1.4부터 제공하는 LinkedHashSet 클래스를 사용하면 된다

또한 Set은 객체를 중복해서 저장할 수 없고 하나의 중복 저장이 안 되기에 null 값도 하나만 저장할 수 있다. Set 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복은 허영되지 않기 때문이다. Set 컬렉션을 구현하는 대표적인 클래스들은 HashSet과 TreeSet이 있다.

### Set 클래스 주요 메서드

| 메서드                     | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| boolean add(E e)           | 주어진 객체를 저장 후 성공적이면 true를 중복 객체면 false를 리턴합니다. |
| boolean contains(Object o) | 주어진 객체가 저장되어있는지 여부를 리턴합니다.              |
| Iterator<E> iterator()     | 저장된 객체를 한번씩 가져오는 반복자를 리턴합니다.           |
| isEmpty()                  | 컬렉션이 비어있는지 조사합니다.                              |
| int Size()                 | 저장되어 있는 전체 객체수를 리턴합니다.                      |
| void clear()               | 저장된 모든 객체를 삭제합니다.                               |
| boolean remove(Object o)   | 주어진 객체를 삭제합니다.                                    |

### HashSet이란?

(중복을 걸러내는 과정) HashSet은 객체를 저장하기 전에 먼저 객체의 **hashCode()** 메소드를 호출해서 해시 코드를 얻어낸 다음 저장되어 있는 객체들의 해시 코드와 비교한 뒤 같은 해시 코드가 있다면 다시 **equals()** 메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다. 문자열을 HashSet에 저장할 경우, 같은 문자열을 갖는 String 객체는 동일한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주되는데, 그 이유는 String 클래스가 hashCode()와 equalsI() 메소드를 재정의해서 같은 문자열일 경우 hashCode()의 리턴 값을 같게, equals()의 리턴 값은 true가 나오도록 했기 때문이다.

[Hash](https://www.notion.so/Hash-fb27b3807cfc4bfaba808891e195b87d)

### HashSet 선언

```java
HashSet<Integer> set1 = new HashSet<Integer>();//HashSet생성
HashSet<Integer> set2 = new HashSet<>();//new에서 타입 파라미터 생략가능
HashSet<Integer> set3 = new HashSet<Integer>(set1);//set1의 모든 값을 가진 HashSet생성
HashSet<Integer> set4 = new HashSet<Integer>(10);//초기 용량(capacity)지정
HashSet<Integer> set5 = new HashSet<Integer>(10, 0.7f);//초기 capacity,load factor지정
HashSet<Integer> set6 = new HashSet<Integer>(Arrays.asList(1,2,3));//초기값 지정
```

HashSet을 기본으로 생성했을 때에는 initial capacity(16), load factor(0.75)의 값을 가진 Hashset 객체가 생성된다. 저장공간보다 값이 추가로 들어오면 List처럼 저장공간을 늘리는데, Set은 저장공간을 약 두 배로 늘린다. **이 때문에 과부하가 발생하는 경우가 많다. 그렇기에 초기에 저장할 데이터 개수를 알고 있다면 Set의 초기용량을 지정해주는 것이 좋다.**

### TreeSet이란?

JDK 1.2부터 제공되고 있는 TreeSet은 이진 탐색 트리 (BinarySearchTree) 구조로 이루어져 있다. 이진 탐색 트리는 추가와 삭제에는 시간이 조금 더 걸리지만 정렬, 검색에 높은 성능을 보이는 자료구조이다. TreeSet은 데이터를 저장할 시 이진 탐색 트리의 형태로 데이터를 저장하기에 기본적으로 nature ordering을 지원하며 생성자의 매개변수로 Comparator 객체를 입력하여 정렬 방법을 임의로 지정해줄 수도 있다.

### 레드 - 블랙 트리 (자가균형 이진탐색트리)

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/czb0Rs/btqEt6tVogn/KpmfrL9PfiNK9ioz0WkRq1/img.png

TreeSet은 이진 탐색 트리 중에서도 성능을 향상시킨 레드 - 블랙 트리로 구현되어 있다. 일반적인 이진 탐색 트리는 트리의 높이만큼 시간이 걸린다. 데이터의 값이 트리에 잘 분산되어 있다면 효율성에 큰 문제가 없으나 데이터가 들어올 때 값이 편향되게 들어올 경우 한 쪽으로 크게 치우쳐진 트리가 되어 굉장히 비효율적인 퍼포먼스를 낸다. 이 문제를 보완하기 위해 레드-블랙 트리가 등장하였다.

레드 블랙 트리는 부모 노드보다 작은 값을 가지는 노드는 왼쪽 자식으로 ,큰 값을 가지는 노드는 오른쪽 자식으로 배치하여 데이터의 추가나 삭제 시 트리가 한 쪽으로 치우쳐지지 않도록 균형을 맞추어 준다.

### TreeSet에 값이 추가되는 과정

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/SXQBD/btqEtE5Opsm/TyuNWSDe5kDxDoueaNQjsK/img.png

### TreeSet 값 출력

```java
TreeSet<Integer> set = new TreeSet<Integer>(Arrays.asList(4,2,3));//초기값 지정
System.out.println(set); //전체출력 [2,3,4]
System.out.println(set.first());//최소값 출력
System.out.println(set.last());//최대값 출력
System.out.println(set.higher(3));//입력값보다 큰 데이터중 최소값 출력 없으면 null
System.out.println(set.lower(3));//입력값보다 작은 데이터중 최대값 출력 없으면 null
		
Iterator iter = set.iterator();	// Iterator 사용
while(iter.hasNext()) {//값이 있으면 true 없으면 false
    System.out.println(iter.next());
}
```

## Map 컬렉션

Map 컬렉션은 키(key)와 값(value)로 구성된 객체를 저장하는 구조를 가지고 있는 자료구조이다.

키는 중복으로 저장할 수 없고, 값은 중복으로 저장할 수 있으며 중복된 key 값이 들어온다면 기존의 값은 없어지고 새로운 값으로 대치된다.

Map 컬렉션을 구현하는 대표적인 클래스들은 HashMap, Hashtable, LinkedHashMap, TreeMap 등이 있다.

### Map 클래스 주요 메서드

| 메소드                              | 설명                                                       |
| ----------------------------------- | ---------------------------------------------------------- |
| V put(K Key, V value)               | 주어진 키와 값을 추가하여 저장되면 값을 리턴합니다.        |
| boolean containsKey(Object Key)     | 주어진 키가 있는지 확인합니다.                             |
| boolean containsValue(Object value) | 주어진 값이 있는지 확인합니다.                             |
| Set<Map.Entry<K,V>> entrySet()      | 모든 Map.Entry 객체를 Set에 담아 리턴합니다.               |
| Set<K> keySet()                     | 모든 키를 Set객체에 담아서 리턴합니다.                     |
| V get(Object key)                   | 주어진 키에 있는 값을 리턴합니다.                          |
| boolean isEmpty()                   | 컬렉션이 비어있는지 조사합니다.                            |
| int Size()                          | 저장되어 있는 전체 객체의 수를 리턴합니다.                 |
| Collection<V> values()              | 저장된 모든 값을 Collection에 담아서 리턴합니다.           |
| void clear()                        | 저장된 모든 Map.Entry를 삭제합니다.                        |
| V remove(Object Key)                | 주어진 키와 일치하는 Map.Entry를 삭제하고 값을 리턴합니다. |

## HashMap이란?

HashMap은 이름 그대로 Hashing을 사용하기 때문에 많은 양의 데이터를 검색하는 데 있어서 뛰어난 성능을 보인다. 값은 중복 저장될 수 있지만 키는 중복 저장될 수 없다. 여기서 키와 값은 모두 객체이다. 만약 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대치된다.

### HashMap 값 출력

```java
HashMap<Integer,String> map = new HashMap<Integer,String>(){{//초기값 지정
    put(1,"사과");
    put(2,"바나나");
    put(3,"포도");
}};
		
System.out.println(map); //전체 출력 : {1=사과, 2=바나나, 3=포도}
System.out.println(map.get(1));//key값 1의 value얻기 : 사과
		
//entrySet() 활용
for (Entry<Integer, String> entry : map.entrySet()) {
    System.out.println("[Key]:" + entry.getKey() + " [Value]:" + entry.getValue());
}
//[Key]:1 [Value]:사과
//[Key]:2 [Value]:바나나
//[Key]:3 [Value]:포도

//KeySet() 활용
for(Integer i : map.keySet()){ //저장된 key값 확인
    System.out.println("[Key]:" + i + " [Value]:" + map.get(i));
}
//[Key]:1 [Value]:사과
//[Key]:2 [Value]:바나나
//[Key]:3 [Value]:포도
```

`entrySet()`은 key와 value 모두가 필요할 경우 사용하며 keySet()은 key 값만 필요할 경우 사용하는데, key 값만 받아도 get(key)를 활용하여 value에 접근할 수 있기 때문에 어떤 메소드를 선택하든지 간에 큰 상관은 없지만, keySet을 활용하여 value를 찾는 과정에서 시간이 많이 소모되므로 많은 양의 데이터를 가져와야 한다면 `entrySet`이 좋다

### TreeMap이란?

같은 Tree 구조로 이루어진 TreeSet과의 차이점은 TreeSet은 그냥 값만 저장한다면 TreeMap은 키와 값이 저장된 Map, Entry를 저장한다는 점이다. TreeMap에 객체를 저장하면 자동으로 정렬되는데, 키는 저장과 동시에 자동 오름차순으로 정렬되고 숫자 타입일 경우에는 값으로, 문자열 타입일 경우에는 유니코드로 정렬한다. 정렬 순서는 기본적으로 부모 키값과 비교해서 키값이 낮은 것을 왼쪽 자식 노드에 키값이 높은 것은 오른쪽 자식 노드에 Map.Entry 객체를 저장한다. TreeMap은 일반적으로 Map으로써의 **성능이 HashMap보다 떨어**진다.

TreeMap은 데이터를 저장할 때 즉시 정렬하기에 **추가나 삭제가 HashMap 보다 오래** 걸린다. **하지만 정렬된 상태로 Map을 유지해야 하거나 정렬된 데이터를 조회해야 하는 범위 검색이 필요한** 경우 TreeMap을 사용하는 것이 효율성면에서 좋다.