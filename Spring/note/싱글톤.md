# 싱글톤

## 싱글톤 패턴이란?

- Singleton 패턴의 정의는 단순하다. **객체의 인스턴스가 오직 1개**만 생성되는 패턴을 의미한다.

```java
public class Printer {
		private static Printer printer = null;

		private Printre() {}

		public static Printer getInstance() {
			if(printer == null;) {
					printer = new Printer();
			}
			return printer;
		}
			
		public void print(String input) {
				System.out.println(input);
		}
}
```

- 기본 생성자를 `private` 를 사용하여 생성을 불가능하게 하고 `getInstance`를 통해서만 생성이 가능하다. 기존에 생성된 값이 존재한다면 생성된 인스턴스를 리턴하고, 없다면 생성한다. 또한, 인스턴스를 제공하는 메소드와 인스턴스 변수 모두 `Static`으로 선언된 정적 변수 및 메소드이다. 당연히 기본 생성자를 통해 생성할 수 없기 때문에 외부에서 인스턴스에 접근하려면 클래스 변수 및 메소드에 접근을 허용해야 하기 때문에 두 메소드는 정적타입으로 선언하는 것이다.
- 이처럼 인스턴스를 오직 한 개로만 가져오면 메모리 측면에서 이점을 얻을 수 있다. 최초 한 번의 `new` 연산자를 통해서 고정된 메모리 영역을 사용하기 때문에 추후에 해당 객체에 접근할 때 메모리 낭비를 방지할 수 있다. 뿐만 아니라 이미 생성된 인스턴스를 활용하니 속도 측면에서도 이점이 있다고 볼 수 있다.
- 또다른 이점은 다른 클래스 간에 **데이터 공유가** **쉽다는 것**이다. 싱글톤 인스턴스가 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있다. 하지만 여러 클래스의 인스턴스에서 싱글톤 인스턴스의 데이터에 동시에 접근하게 되면 동시성 문제가 발생할 수 있으니 이점을 유의해서 설계하는 것이 좋다.

## 싱글톤 패턴의 문제점

- 먼저 싱글톤 패턴을 구현하는 코드 자체가 많이 필요하다. 앞서 소개한 구현 방법외에도 정적 팩토리 메소드에서 객체 생성을 확인하고 생성자를 호출하는 경우에 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 `syncrionized` 키워드를 사용해야 한다.
- 두 번째는 테스트하기 어렵다는 것이다. 싱글톤 인스턴스는 자원을 공유 하고 있기 때문에 테스트가 결정적으로 격리된 환경에서 수행되려면 매번 인스턴스의 상태를 초기화시켜 주어야 한다 (AfterEach, BeforeEach)
- 세 번째로는 의존 관계상 클라이언트가 구체 클래스에 의존하게 된다. `new` 키워드를 직접 사용하여 클래스 안에서 객체를 생성하고 있으므로, 이는 SOLID 원칙 중 DIP를 위반하게 되고 OCP 원칙 또한 위반할 가능성이 높다????

## 해결

1. **정적 변수에 인스턴스를 만들어 바로 초기화 하는 방법**

정적 변수는 객체가 생성되기 전 클래스가 메모리에 로딩될 때 만들어져 초기화가 한 번만 실행된다. 또한 정적 변수는 프로그램이 시작될 때부터 종료될 때까지 없어지지 않고 메모리에 계속 상주하며 클래스에서 생성된 모든 객체에서 참조할 수 있다. 따라서 기존에 조건문에서 체크하던 부분이 원천적으로 제거된다.

- 하지만, 이 경우에도 Count 값은 각기 다르게 접근하기 때문에 쓰레드마다 값이 달라진다. 객체 생성 자체는 로드 시점에서 결정되어 하나의 객체만을 사용하지만 Count에 접근하는 것은 동시적으로 접근하기 때문에 그렇다. 이때 사용하는 것이 `syncronized` 라는 키워드 이다. (쓰레드를 동시에 접근하는 것을 막음)

  ```java
  public class Printer {
      	private static Printer printer = new Printer();
      	private static int count = 0;
      
      	private Printer(){}
      
      	public static Printer getInstance() {
      		return printer;
      	}
      
      	public synchronized static void print(String input) {
      		count++;
      		System.out.println(input + "count : "+ count);
      	}
      }
  ```

- 위와 같이 정적 클래스를 이용하면 객체를 전혀 생성하지 않고 메소드를 사용할 수 있고 인스턴스 메소드를 사용하는 것보다 성능 면에서 우수하다고 볼 수 있다.

1. **인스턴스를 만드는 메소드에 동기화하는 방법**

하지만 정적 클래스를 사용할 수 없는 경우 또한 존재한다. 인터페이스를 구현하는 경우이다. 인터페이스가 정적 메소드를 가질 수 없기 때문에 이런 경우 정적 클래스를 사용할 수 없다.

```java
public interface Printer {
		public void print(String input);
}

------------------------------------

public class RealPrinter implements Printer {
		private static Printer printer = null;

		private RealPrinter() {}

		public synchronized static Printer getInstance() {
				if(printer == null)
						printer = new RealPrinter();
				return printer;
		}

		@Override
		public void print(String input) {
			System.out.println(input);
		}
	}

---------------------------------------
public class UsePrinter {
			public void doSomething(Printer printer) {
					printer.print("fakeGet");
		}
}
----------------------------------------
public class FakePrinter implements Printer{
		private String str;
		
		public void print(String str) {
			this.str = str;
		}
		
		public String get() {
			return str;
		}
}

--------------------------------------
class UsePrinterTest {
		@Test
		void testDoSomething(){
			FakePrinter fake = new FakePrinter();
			UsePrinter use = new UsePrinter();
			use.doSomething(fake);
			assertThat("fakeGet").isEqualTo(fake.get));
		}
}
```

d