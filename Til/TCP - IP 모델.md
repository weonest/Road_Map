# TCP/IP 모델

------

이번 글에서는 우아한테크의 테코톡에서 히히님이 발표하신 OSI 7계층에 대해서 정리를 해보려고 한다.

[[10분 테코톡\] 🔮 히히의 OSI 7 Layer](https://youtu.be/1pfTxp25MA8)

우선 본론으로 들어가기에 앞서 현대의 우리가 주로 사용하는 네트워크 모델은 OSI 7계층이 아니라는 사실을 아는가? OSI 7계층 TCP/IP 모델과의 경쟁에서 밀려 시장 점유율을 뺏긴지 오래라고 한다. 즉, 오늘날 우리들이 사용하는 인터넷 프로토콜의 대부분은 TCP/IP 모델이라는 것이다.

![https://velog.velcdn.com/images/amuse/post/c8714fe2-f8a4-4670-8c4e-71c888987e7f/similarities-and-differences-between-osi-and-tcp-ip-model.png](https://velog.velcdn.com/images/amuse/post/c8714fe2-f8a4-4670-8c4e-71c888987e7f/similarities-and-differences-between-osi-and-tcp-ip-model.png)

(이미지 출처 : https://velog.io/@amuse/OSI-7-Layers )

정확히는 TCP/IP Updated 모델이 현대의 인터넷이 사용하는 모델이다 . 그럼에도 OSI 7계층은 이질적인 시스템간의 상호작용과 네트워크 구조를 이해하는 데 도움이 되기 때문에 꼭 알아두도록 하자.

위 사진의 TCP/IP Updated의 구조를 1계층부터 살펴보도록 하자.

## 1. Physical Layer

> 1계층

컴퓨터는 똑똑하면서도 단순하다. 컴퓨터는 `0`과 `1`만 주고받을 수 있으면 모든 파일과 프로그램을 읽고 실행할 수 있다. 단순한 만큼 빠르게 처리할 수 있기 때문에 무수히 많은 0과 1로 이루어진 정보들도 컴퓨터로 뚝딱 계산을 하여 우리 생활에 많은 도움을 주고 있다.

컴퓨터는  `0`과 `1`의 나열을 아날로그 신호로 바꾸어 **전선**으로 흘려보내는 `Encoding` 과정과 흘러 들어온 신호를 해석하는 `Decoding` 과정을 통해 통신을 주고 받는다. 이러한 과정을 가능케 해주는 것이 바로 `Phsical Layer`이다.

Physical Layer는 이름에서 알 수 있듯이 **물리적으로** 연결된 두 대의 컴퓨터가 0과 1의 나열을 주고받을 수 있게 해주는 Module인데, `PHY`칩 이라는 부품으로 `하드웨어적`으로 구현이 되어있다.

## 2. Data - Link Layer

> 2계층

여러 대의 컴퓨터가 통신하려면 어떻게 해야 할까? 위의 1계층에서의 정보를 토대로 생각해보면, 물리적인 전선으로 통신하고 싶은 여러 대의 컴퓨터들을 이어주기만 하면 가능할 것이다. 그런데 만약 수 만대의 컴퓨터가 서로 통신을 하고 싶은 경우라면? 물리적인 전선을 모두 연결해 주는 것으로 해결은 가능하겠지만, 전선을 연결하기 위한 구멍이라던가 전선을 설치하는 비용 등에서도 한계점이 찾아올 것이다.

![https://blog.kakaocdn.net/dn/781co/btroJhqrOL8/Ab2gCkaqplUfpY6tglAm0K/img.png](https://blog.kakaocdn.net/dn/781co/btroJhqrOL8/Ab2gCkaqplUfpY6tglAm0K/img.png)

(이미지 출처 : https://jhnyang.tistory.com/entry/네트워크-OSI-3계층-네트워크-계층-하는-역할이-뭔가요-네비게이터가-길-찾는법)

이에 대한 해결법으로 `Switch` 가 존재한다. Switch는 쉽게 말하면 **중계기, 공유기**이다. 각 컴퓨터들을 이 Switch와 연결을 함으로써 모두가 연결된 것과 같은 효과를 얻을 수 있다. 이렇게 **Swith와 연결된 수 많은 컴퓨터들의 집합**을 우리는 **네트워크**라고 부른다.

좀 더 나아가서 자신의 네트워크에 속하지 않은 컴퓨터에게 정보를 전달하려고 할 때는 어떻게 하면 좋을까? 이때에는 Switch와 Switch를 연결하여 서로 다른 네트워크에 속한 컴퓨터끼리 통신을 가능케 하는 `Router`를 사용하면 된다. Router의 상위 계층으로 올라가면 국가와 국가 간의 통신을 연결해야 하는 지점이 존재하는데, 우리는 이러한 지점에 해저 케이블을 설치하여 글로벌 네트워크를 구축하고 있으며, 이러한 식으로 전 세계의 컴퓨터들이 계층구조로 연결되어 있는 것을 **인터넷**이라고 한다.

이번엔 이와 같이 수 많은 컴퓨터가 연결된 상황에서 생각해볼 수 있는 한 가지 상황을 이야기해보자.  `A, B, C` 라는 컴퓨터가 각각 `0101, 1110, 0001` 이라는 데이터를 `D` 컴퓨터에게  거의 동시에 보낸다면 D 컴퓨터는 `010111100001` 과 같은 형태로 데이터를 받게된다. 이러한 데이터를 어디서 끊어 읽는지에 따라 옳바른 데이터 처리가 결정될 것이다. 이를 위해 송신자는 데이터의 앞 뒤에 특정한 bit열을 붙인다.

예를 들자면 **시작을 의미**하는 1111과 **끝을 의미**하는 0000을 붙여 1111 0101 0000과 같은 형태로 데이터를 보내는 것이다. 이러한 작업을 `Framing`이라고 한다.

정리하자면, Data - Link Layer란 같은 네트워크에 있는 여러 대의 컴퓨터들이 데이터를 주고받기 위해서 필요한 모듈인 것이다. 2계층 모듈 역시 1계층 모듈과 마찬가지로 LAN 카드라는 부품으로 하드웨어적으로 구현이 되어 있다.

## 3. Network Layer

> 3계층

위에서 들었던 예시를 다시 적용하여 자신이 속한 네트워크가 아닌 다른 네트워크의 컴퓨터에게 데이터를 보내기 위해서는 상대방의 IP 주소를 알아야 한다. IP 주소를 어떻게 알 수 있냐하면 사실 우리는 이미 IP 주소를 알고 있다.  [www.naver.com](http://www.naver.com) 을 입력하면 DNS를 통해 IP 주소로 변환되어 해당 IP에 접속하는 것처럼 이미 우리는 상대방의 IP 주소를 알고 있다.

위에서는 아까 Framing이라는 작업을 통해 데이터의 시작과 끝을 알렸던 것처럼, 이곳에서는 데이터의 앞에 IP 주소를 붙여 `Packet`이라는 데이터를 만들어 전송한다.

라우터는 전달받은 패킷을 열어 IP 주소를 확인하고 자신이 전달할 수 있으면 전달하고, 그렇지 못한다면 다른 라우터로 다시 보내주어 목적지까지 배달한다.

이렇듯 수많은 네트워크들의 집합 Inter Network 속에서 IP 주소를 이용해 길을 찾는 것을 `Routing`, 이것을 다음 라우터에게 넘겨주는 것을 `Forwarding`이라 한다.

> **😁 네트워크 데이터 단위**
>
> - Socket에서 다루는 데이터 단위는 
>
>   Stream
>
>   - Stream : 시작은 알지만 끝은 모름
>   - Socket을 Network단으로 보내면 Stream 데이터가 Segment화 된다 (데이터를 자름) = Segmentaion
>
> - TCP에서 다루는 데이터 단위 
>
>   Segment
>
>   - Socket에서 받은 잘린 Stream 데이터
>   - MSS (Maximum Segment Size) 일정 길이의 최대값. MSS는 MTU보다 당연히 작다
>
> - IP에서 다루는 데이터 단위 
>
>   Packet
>
>   - Segment를 인터넷 환경에서 전송 가능한 상태로 포장한 형태
>   - MTU (Maximum Trasnport Unit) 특별한 이유가 없다면 1500bytes
>
> - H/W단에서 다루는 데이터 단위 
>
>   Frame
>
>   - Packet을 실어 나를 때는 다시 Frame 데이터에 넣는다

3계층은 운영체제의 Kernel에 소프트웨어적으로 구현되어있다.

> 😎 **Kernel** 이란?
>
> 커널은 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로써 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 **자원들을 관리하는 역할을 한다**.
>
> 즉, 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고, 여러가지 하드웨어 (CPU, Memory) 등의 리소스를 관리하는 역할을 한다.
>
> https://minkwon4.tistory.com/295

## 4. Transport Layer

> 4계층

위의 3가지 계층들을 통해 우리는 세계적인 범위로 데이터를 주고받을 수 있게 되었다. 그렇다면 이제 전송받은 혹은 전송한 데이터를 어떠한 프로세스에게 어떻게 전달해주면 좋을까? 우리는 `Port`를 통해 이를 전달하고 있다. 실행중인 프로그램(`프로세스`)들은 모두 고유한 정수의 Port 번호를 지니고 있다. `MySQL`을 사용해봤다면 `3306`이라는Port 번호가 익숙할 것이다. 또 웹 개발을 진행했다면 `8080`이라는 `Port` 번호 역시 익숙할 것이다.

이처럼 우리는 Port 번호를 이용하여 어떤 프로세스에 어떤 데이터를 넘길 것인지 결정할 수 있게 된다. 따라서 데이터 송신자는 데이터를 보낼 때 데이터를 받을 수신자 컴퓨터에 있는 프로세스의 Port 번호를 붙여서 보내야 한다.

> 우리가 검색창에 [www.naver.com](http://www.naver.com) 을 입력하는 것은 사실 [www.naver.com:80](http://www.naver.com:80) 이라는 포트 번호를 생략한 형태이다. 즉, 우리는 우리도 모르게 naver의 Port 번호를 알고 데이터를 주고받고 있던 것이다

즉, Transport Layer란 Port 번호를 사용하여 도착지 컴퓨터의 최종 도착지인 프로세스에 까지 데이터가 도달하게 하는 모듈인 것이다. 이 역시 3계층과 마찬가지로 운영체제의 커널에 소프트웨어적으로 구현되어 있다.

## 5. Application Layer

> 5계층

사용자와 가장 가까운계층으로 **사용자 - 소프트웨어 간 소통을 담당하는 계층**이다.

애플리케이션을 실행하기 위한 데이터 형식이 작성된다.

> TCP/IP 소켓 프로그래밍
>
> - 운영체제의 Transport Layer 에서 제공하는 **API를 활용해서 통신 가능한 프로그램**을 만드는 것. 다른 말로 소켓 프로그래밍, 네트워크 프로그래밍이라고 함
> - 소켓 프로그래밍만으로도 클라이언트, 서버 프로그램을 따로따로 만들어서 동작 시킬 수 있다
> - TCP/IP 소켓 프로그래밍을 통해서 누구나 자신만의 Application Layer 인코더와 디코더를 만들 수 있다. → 자신만의 프로토콜을 만들어서 사용할 수 있다

대표적인 프로토콜로 HTTP, HTTPS, FTP, SSH, DNS, SMTP 등이 있다.