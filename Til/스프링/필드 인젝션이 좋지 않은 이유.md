# 필드 인젝션이 좋지 않은 이유

------

https://yaboong.github.io/spring/2019/08/29/why-field-injection-is-bad/

나는 지금껏 스프링에서 의존관계를 주입 받을 때 당연하다는 듯이 @Autowired를 사용한 필드주입 방식을 사용해왔다. 그런데 어느날 한 유튜브 강의에서 필드 인젝션을 자제해야 한다는 이야기를 듣게 되었고, 왜? 라는 의문과 동시에 여태껏 모든 주입을 필드 인젝션을 통해 해결해왔던 나의 코딩 인생이 부정당하는 느낌이 들어 찾아보게 되었다.

## DI (Dependency Injection 의존관계 주입)

이유를 알기 위해선 DI에 대한 이해가 필요하다. DI는 스프링에서만 사용되는 용어가 아니라 객체지향 프로그래밍 어디에서나 통용되는 개념이다

### 강한 결합

객체 내부에서 다른 객체를 생성하는 것은 강한 결합도를 가지는 구조이다. A클래스 내부에서 B라는 객체를 직접 생성하고 있다면, B 객체를 C 객체로 바꾸고 싶은 경우에 A 클래스도 수정해야 하는 방식이기 때문이다.

### 느슨한 결합

객체를 주입 받는다는 것은 외부에서 생성된 객체를 인터페이스를 통해셔 넘겨받는 것이다. 이렇게 하면 결합도를 낮출 수 있고, 런타임 시에 의존관계가 결정되기 때문에 유연한 구조를 가진다.

SOLID 원칙에서 O에 해당하는 Open-Closed Principle(개방폐쇄 원칙)을 지키기 위해서 디자인 패턴 중 전략패턴을 사용하게 되는데, 생성자 주입을 사용하게 되면 전략패턴을 사용하게 된다.

### Setter Based Injection (수정자를 통한 주입)

의존관계 주입에는 크게 생성자 주입, 수정자 주입 두 가지 방법이 있다.

순수 Java 코드를 통해 알아보자

```java
public class Controller {
    private Service service;

    public void setService(Service service) {
        this.service = service;
    }

    public void callService() {
        service.doSomething();
    }
}
public interface Service {
    void doSomething();
}
public class ServiceImpl implements Service {
    @Override
    public void doSomething() {
        System.out.println("ServiceImpl is doing something");
    }
}
public class Main {
    public static void main(String[] args) {
        Controller controller = new Controller();

        // 어떤 구현체이든, 구현체가 어떤방법으로 구현되든 Service 인터페이스를 구현하기만 하면 된다.
        controller.setService(new ServiceImpl1());
        controller.setService(new ServiceImpl2());

        controller.setService(new Service() {
            @Override
            public void doSomething() {
                System.out.println("Anonymous class is doing something");
            }
        });

        controller.setService(
          () -> System.out.println("Lambda implementation is doing something")
        );

        // 어떻게든 구현체를 주입하고 호출하면 된다.
        controller.callService();
    }
}
```

- Controller 클래스의 callService() 메서드는 Service 타입의 객체에 의존하고 있다.

- Service는 인터페이스이고, 인터페이스는 인스턴스화 할 수 없으므로 인터페이스의 구현체가 필요하다.

- Service 인터페이스를 구현하기만 했다면 어떤 타입의 객체라도 Controller에서 사용할 수 있는데 (다형성) 

  Controller는 이 구현체의 내부 동작을 아무것도 알지 못하고 알 필요도 없다.

  - 인터페이스의 구현체는 해당 인터페이스가 파라미터로 들어갈 수 있다면 모든 구현체 역시 파라미터로 들어갈 수 있기 때문 (다형성)

- main 함수에서 Controller 클래스를 사용하는 것을 보면, 수정자 메서인 setService()에 Service 인터페이스의 구현체만 넘겨주면 된다

어떤 구현체이든, 구현체가 어떤 방법으로 구현되든, Service 인터페이스를 구현하기만 하면 된다 → 신박하네?

수정자 주입으로 의존관계 주입은 **런타임 시에 할 수 있도록 낮은 결합도**를 가지게 구현되었다. 하지만 문제는 수정자를 통해서 Service의 구현체를 주입해주지 않아도 Controller 객체는 생성 가능하다. Controller 객체가 생성가능하다는 것은 내부에 있는 callService() 메서드도 호출 가능하다는 것인데, callService() 메서드는 service.doSomething() 을 호출하고 있으므로 `NullPointerException`이 발생한다.

**주입이 필요한 객체가 주입이 되지 않아도 얼마든지 객체를 생성할 수 있다는 것이 문제이다**.

이러한 문제를 해결할 수 있는 방법이 **생성자 주입**이다.

### Constructor based Injection (생성자를 통한 주입)

Controller 에서 setter를 없애고, 생성자를 이용해서 주입한다.

```java
public class Controller {
    private Service service;

    **public Controller(Service service) {
        this.service = service;
    }**

    public void callService() {
        service.doSomething();
    }
}
```

이렇게 생성자를 주입해주면 main 메서드는 아래와 같이 바뀐다.

```java
public class Main {
    public static void main(String[] args) {

        // Controller controller = new Controller(); // 컴파일 에러

        Controller controller1 = new Controller(new ServiceImpl());
        Controller controller2 = new Controller(
            () -> System.out.println("Lambda implementation is doing something")
        );
        Controller controller3 = new Controller(new Service() {
            @Override
            public void doSomething() {
                System.out.println("Anonymous class is doing something");
            }
        });

        controller1.callService();
        controller2.callService();
        controller3.callService();
    }
}
```

이를 통해 두 가지 이득과 한 가지 보너스 이득이 생긴다.

1. null을 주입하지 않는 한 `NullPointerException`은 발생하지 않는다
2. `의존관계 주입을 하지 않은 경우`에는 Controller `객체를 생성할 수 없다`. 즉, 의존관계에 대한 내용을 외부로 노출시킴으로써 컴파일 타임에 오류를 잡아낼 수 있다.

보너스 이득은 `final`을 사용할 수 있다는 것이다. final로 선언된 레퍼런스타입 변수는 반드시 선언과 함게 초기화가 되어야 하므로 setter 주입시에는 의존관계 주입을 받을 필드에 final을 선언할 수 없다.

- final 선언은 객체의 불변성을 보장한다

```java
public class Controller {
    **private final Service service; // final 추가**

    public Controller(Service service) {
        this.service = service;
    }

    public void callService() {
        service.doSomething();
    }
}
```

final의 장점은 누군가가 Controller 내부에서 service 객체를 수정할 수 없다는 점이다. 스프링에서 필드 주입은 수정자를 통한 주입과 유사한 방식으로 이루어진다.

## 스프링에서의 DI 방법 세 가지

스프링에서는 수정자 주입, 생성자 주입과 더불어 필드 주입이란 걸 할 수 있다. 필드 주입은 수정자를 통한 주입과 유사한 방식으로 이루어지기 때문에, 수정자를 통한 주입의 단점인 final 사용 불가라는 단점을 그대로 가진다.

더불어, 수정자 주입은 스프링 컨테이너가 아닌 외부에서 수정자를 호출해서 주입할 수 있는 방법이라도 열려있지만, 필드주입은 스프링 컨테이너 말고는 외부에서 주입할 수 있는 방법이 없다.

아래는 각 DI 방법에 대한 간단한 예제다.

**Field Injection**

```java
@Service
public class StudentServiceImpl implements StudentService {

    @Autowired
    private CourseService courseService;

    @Override
    public void studentMethod() {
        courseService.courseMethod();
    }

}
```

**Setter based Injection**

```java
@Service
public class StudentServiceImpl implements StudentService {

    private CourseService courseService;

    @Autowired
    public void setCourseService(CourseService courseService) {
        this.courseService = courseService;
    }

    @Override
    public void studentMethod() {
        courseService.courseMethod();
    }
}
```

**Consturcotr based Injection**

```java
@Service
public class StudentServiceImpl implements StudentService {

    private final CourseService courseService;

    @Autowired
    public StudentServiceImpl(CourseService courseService) {
        this.courseService = courseService;
    }

    @Override
    public void studentMethod() {
        courseService.courseMethod();
    }
}
```

### 생성자 주입을 이용한 순환참조 방지

개발을 진행하다보면 여러 서비스들 간에 의존관계가 생기게 되는 경우가 있다. 이때 서로가 서로를 무한하게 참조하는 순환참조가 발생하는 경우가 있다. (Entity의 양방향 맵핑에서 볼 수 있는 것처럼)

Spring Boot 2.6.x 버전 부터 순환참조를 원칙적으로 금지하고 있는데, 필드 주입 혹은 생성자 주입을 통해 만들어진 순환참조는 실제로 해당 코드가 호출이 되기 전까지는 오류를 잡아낼 수가 없다. 만약 호출을 하게 된다면 서로가 서로를 무한하게 호출하기 때문에 Stack 메모리가 터져버리는 StackOverflowError를 뱉게 될 것이다.

하지만, 생성자 주입은 Bean 생성 시에 아래와 같은 로직이 수행되면서 어떠한 시점에서 스프링이 그것을 순환참조라고 캐치하여 순환참조 오류를 뱉어준다.

```java
new CourseServiceImpl(new StudentServiceImpl(new CourseServiceImpl(new ...)))
```

이러한 차이는 Bean을 주입하는 순서가 다르다는 점에서 온다.

> **Setter based Injection & Field Injection**
>
> 위 방식은 Bean을 먼저 생성한 후에 애노테이션이 붙은 필드에 해당하는 Bean을 찾아서 주입하는 방식이다. 즉, Bean을 먼저 생성한 후에 필드에 대해서 주입하기 때문에 Bean 객체를 생성한 시점에는 순환 참조의 발생 여부를 알 수가 없다 (**생성 → 주입**)
>
> **Constructor based Injection**
>
> 반면, 생성자 주입은 생성자로 객체를 생성하는 시점에 필요한 Bean을 주입한다. 다시 말하면, Bean 객체를 생성하는 시점에 생성자의 파라미터 Bean 객체를 찾아서 먼저 주입한 뒤에 주입받은 Bean 객체를 이용하여 생성하게 된다. (**주입 → 생성**)
>
> 이러한 이유로  객체 생성 시점에 Bean을 주입하기 때문에 서로 참조하는 객체가 생성되지 않은 상태에서 해당 Bean을 참조하기 때문에 런타임 시점이 아니라 애플리케이션 구동 시점에서 순환 참조 오류를 발견할 수 있는 것

### Test 코드 작성 시 용이

필드 & 수정자 주입의 경우 의존관계를 주입 받으려면 반드시 스프링 컨테이너를 필요로 한다. (IoC / 의존 역전 원칙)

단위 테스트의 경우 스프링 컨테이너를 로드하지 않은 상태에서 테스트를 수행하게 되는데, 이때 테스트 대상의 필드가 필드주입을 사용하고 있다면 의존관계를 주입받지 못하므로 테스트를 진행할 수 없게 되기 때문이다.

다라서, 생성자 주입이나 수정자 주입을 사용하여 스프링 컨테이너 없이도 의존관계를 주입하는 방식을 사용하는 것이 테스테에 용이하다고 볼 수 있다.