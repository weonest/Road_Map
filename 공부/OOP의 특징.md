# OOP의 특징

------

https://www.codestates.com/blog/content/객체-지향-프로그래밍-특징

객체 지향 프로그래밍 (Object - Oriented Programing) 이란 컴퓨터 프로그램을 어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록으로 보는 시각에서 벗어나 **여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임**을 의미한다.

마치 자동차를 만든다고 했을 때, 수 많은 부품들의 결합과 연결로 하나의 완전한 자동차가 만들어지는 것과 같다고 할 수 있다. 객체 지향적으로 소프트웨어를 설계한다는 말의 의미는 어떤 프로그램의 일부분에 해당하는 작은 부품, 즉 객체를 먼저 만들고 이렇게 만들어진 여러 객체들을 조립해서 하나의 완성된 프로그램을 만드는 프로그래밍 방법론을 뜻한다. 여기서 각 부품에 해당하는 객체에 대해서는 아래에서 좀 더 자세히 알아보도록 하겠다.

## 객체 지향 프로그래밍의 장점

가장 큰 이점 중에 하나는 객체 지향적 설계를 통해서 프로그램을 보다 유연하고 변경이 용이하게 만들 수 있다는 점이다. 마치 컴퓨터 부품을 갈아 끼울 때, 해당하는 부품만 쉽게 교체하고 나머지 부품들을 건드리지 않아도 되는 것처럼 소프트웨어를 설계할 때 객체 지향적 원리를 잘 적용해 둔 프로그램은 각각의 부품들이 각자의 **독립적인 역할**을 가지기 때문에 코드의 변경을 최소화하고 유지보수를 하는데 유리하다. → **확장성과 유지보수**에 좋다!

더 나아가, **코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현**할 수 있다. 또한 객체 지향 프로그래밍은 실제 우리가 보고 경험하는 세계를 최대한 프로그램 설계에 반영하기 위한 지속적인 노력을 통해 발전해왔기 때문에, 보다 **인간 친화적이고 직관적인 코드**를 작성하기에 용이하다.

객체 지향 프로그래밍의 4가지 특징은 각각 추상화, 상속, 다형성, 캡슐화인데, 모두 이러한 객체 지향적 설계의 이점들을 가장 잘 살릴 수 있는 방향으로 발전되어 왔다고 할 수 있다.

이러한 맥락에서, 지금부터 객체 지향 프로그래밍의 가장 기본적인 단위이자 시작점이 되는 객체 개념과 더불어 각 특징들의 내용을 살펴보면서 각 특징이 어떻게 객체 지향적 설계를 하는데 도움을 줄 수 있는지 이해해보도록 하겠다.

## 객체(Object)란?

앞서 언급한 것처럼, **객체는 객체 지향 프로그래밍의 가장 기본적인 단위이자 시작점**이라 할 수 있다. 객체 지향 개념의 가장 기본적인 전제는 실제 세계는 객체들로 구성되어 있으며, 보여지는 모든 현상과 발생하는 모든 사건은 이러한 **객체들 간의 상.호.작.용**을 통해 발생한다는 것에서 출발한다.

## 객체 지향 프로그래밍의 4가지 특징

우리는 객체 지향 프로그래밍이 우리가 보고 인지하는 실제 세계를 흉내 내어 가장 기본적인 단위인 객체들을 만들고, 그것들 간의 유기적인 상호작용을 규정하여 프로그램을 발전시키는 프로그래밍 방법론임을 이해할 수 있었다.

또한, 객체 지향적 설계를 통해 소프트웨어를 개발하면 코드의 재사용을 통해 반복적인 코드를 최소화하고, 보다 유연하고 변경이 용이한 프로그램을 만들 수 있다는 사실을 알 수 있었다. 마지막으로, 이러한 설계는 앞서 언급한 객체 지향 프로그래밍의 4가지 특징에서 기인하는 것이라고 했다.

### 1. 추상화(Abstration)

추상이라는 용어의 사전적 의미를 보면 “사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것”이라 정의하고 있다. 여기서 핵심이 되는 개념은 “**공통성과 본질을 모아 추출**”한다는 것이다.

예를 들면, 서울의 지하철 노선도는 서울의 지리를 추상화시켜서 보여주는 대표적인 예라 할 수 있다. 중요한 부분을 강조하기 위해 **불필요한 세부 사항들은 제거하고 가장 본질적이고 공통적인 부분만을 추출하여 표현**하는 것과 관련이 있다.

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체-지향-프로그래밍-추상화.png?resize=768,509&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B6%94%EC%83%81%ED%99%94.png?resize=768,509&ssl=1)

위의 예시를 보면, 자동차와 오토바이는 모두 이동 수단이며 모든 이동 수단은 전진과 후진을 할 수 있다는 공통점을 가진다. 이것을 자바 문법 요소를 사용하여 표현하면, **자동차와 오토바이라는 하위 클래스들의 공통적인 기능**(전진, 후진)을 **추출**하여 **이동 수단 이라는 상위 클래스**에 정의했다. 위의 예제에서는 편의상 공통적인 기능만 추출했지만, **공통적인 속성도 추출**하여 선언하는 것이 가능하다.

자바에서 추상화를 구현할 수 있는 문법 요소로는 추상 클래스와 인터페이스가 있는데, 인터페이스를 예를 들어보자.

```java
public interface Vehicle {
		public abstract void start()
		void moveForward(); // public abstract 생략 가능
		void moveBackward();
```

객제 지향적 설계에 있어서 인터페이스는 어떤 객체의 역할만을 정의하여 객체들 간의 관계를보다 유연하게 연결하는 역할을 담당한다.

다른 말로 표현하면, 인터페이스에는 추상 메서드나 상수를 통해서 어떤 객체가 수행해야 하는 핵심적인 역할만을 규정해두고, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록 프로그램을 설계하는 것을 의미한다.

> **추상클래스 사용 시기 :** 상속 관계를 쭉 타고 올라갔을때 같은 조상클래스를 상속하는데 기능까지 완변히 똑같은 기능이 필요한 경우
>
> **인터페이스 사용 시기 :** 상속 관계를 쭉 타고 올라갔을때 다른 조상클래스를 상속하는데 같은 기능이 필요할 경우 인터페이스 사용

### 2. 상속(Inheritance)

상속이란 기존의 클래스를 재활용하여 새롱누 클래스를 작성하는 자바의 문법 요소를 의미한다.

앞서 봤었던 추상화의 연장선에서, 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 한다.

즉, 클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 재사용 할 수 있어 반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근하여 사용할 수 있도록 한다.

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체-지향-프로그래밍-추상화-상속.png?resize=768,509&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B6%94%EC%83%81%ED%99%94-%EC%83%81%EC%86%8D.png?resize=768,509&ssl=1)

위의 예시를 통해 만들면 다음과 같다.

```java
public class Vehicle {
		
	String model;
	String color;
	int wheels;
	
	void moveForward();
	void moveBackward();
}
public class Car extends Vehicle {
	boolean isConvertible;

	void openWindow();
}
public class MotorBike extends Vehicle {
	boolean isRaceable;

	@Override
	void moveForward() {
		sout.("오토바이 나가요~")
	}
}
```

Car와 MotorBike 클래스의 공통적이 속성과 기능들을 추출(추상화)하여 Vehicle 클래스에 정의하였고, extends 키워드를 통해 각각의 하위 클래스로 확장하여 해당 기능과 속성들을 매번 반복적으로 정의해야 하는 번거로움을 제거했다. 또한, 공통적인 코드의 변경이 있는 경우 상위 클래스에서 단 한 번의 수정으로 모든 클래스에 변경 사항이 반영될 수 있도록 만들었다.

참고로, MotorBike 클래스에서 확인할 수 있듯이, 상위 클래스의 기능과 속성들을 그대로 사용할 수도 있지만, 각각의 클래스의 맥락에 맞게 **메서드 오버라이딩**을 사용하여 내용을 정의할 수도 있다.

사실 이 부분이 앞서 추상화에서 봤었던 **인터페이스를 통한 구현과 상속을 구분하는 핵심적인 차이 중에 하나라 할 수 있다.** 즉, 양자 모두 상위 클래스 - 하위 클래스의 관계를 전제하면서 공통적인 속성과 기능을 공유할 수 있지만, 상속의 경우 **상위 클래스의 속성과 기능들을 하위 클래스에서 그대로 받아 사용하거나 오버라이딩을 통해 선택적으로 재정의하여 사용할** 수 있는 반면, 인터페이스를 통한 구현은 반드시 **인터페이스에 정의된 추상 메서드의 내용이 하위 클래스에서 정의**되어야 한다.

결론적으로, 상속 관계의 경우 인터페이스를 사용하는 구현에 비해 추상화의 정도가 낮다고 할 수 있다. 인터페이스가 역할에 해당하는 껍데기만 정의해두고, **하위 클래스에서 구체적인 구현을 하도록 강제하는 것에 비해**, 상속 관계의 경우 상황에 따라 모든 구체적인 내용들을 정의해두고 하위 클래스에서는 그것을 단순히 가져다가 재사용할 수 있다.

### 3. 다형성

다형성은 객체 지향 프로그래밍의 꽃이라 할 수 있다. 이름 그대로 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질을 의미한다.

비유적으로 표현하자면, 어떤 중년의 남성이 있다고 했을 때 그 남자의 역할이 아내에게는 남편, 자식에게는 아버지, 부모님에게는 자식, 회사에서는 회사원 등 상황과 환경에 따라서 달라지는 것과 비슷하다고 할 수 있다.

즉, **어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체 지향의 특성**을 의미한다. 대표적인 예로 우리가 앞서 본 **메서드 오버라이딩과 메서드 오버로딩**이 있다.

앞서 언급한 메서드 오버라이딩과 메서드 오버로딩도 다형성의 한 중요한 예시지만, 객체 지향의 맥락에서 이것보다 더 중요한 다형성의 정의는 이것이다.

> 객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미한다. 좀 더 구체적으로, **상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조**할 수 있도록 하는 것이다

코드를 통해 보자.

```java
public class Main {
		public static void main(String[] args) {
			
		Car car = new Car();
		MotorBike mb = new MotorBike();

		// 다형성 활용
		Vehicle car2 = new Car();
	}
}
```

위의 코드를 확인해보면, 상위클래스 타입의 참조 변수로 하위 클래스 객체를 참조하는 것의 의미를 좀 더 구체적으로 이해할 수 있다. 원래 우리가 사용했던 방식은 하위 클래스의 객체를 생성하여 하위 클래스 타입의 참조 변수에 할당해주었지만, 다형성을 활용한 객체 생성 방식에서는 **하위 클래스의 객체를 생성하여 상위 클래스 타입의 참조 변수**로 car2에 할당해주고 있다.

그렇다면 어째서 이런 다형성을 활용한 방식이 유용할까?

먼저 다형성을 활용하면 여러 종류의 객체를 배열로 다루는 일이 가능해진다.

```java
public class Main {
		public static void main(String[] args) {
			
		Vehicle vehicles[] = new Vehicle[2];
		vehicles[0] = new Car();
		vehicles[1] = new MotorBike();

		for (Vehicle vehicle : vehicles) {
			}
	}
}
```

Vehicle 타입의 객체 배열을 생성해주면, 이제 해당 타입의 참조 변수는 Vehicle 클래스와 상속 관계에 있는 모든 하위 클래스들을 그 안에 담아줄 수 있다. 자바에서 배열의 개념이 **하나의 같은 타입으로 이뤄져 있는 자료구조라**는 점을 통해 이렇게 **다형성을 활용**하면 하나의 타입만으로 여러 가지 타입의 객체를 참조할 수 있어 보다 간편하고 유연하게 코드를 작성하는 것이 가능해 진다.

또 다른 예제를 보자

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체지향프로그래밍-드라이버클래스.png?resize=768,354&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84%ED%81%B4%EB%9E%98%EC%8A%A4.png?resize=768,354&ssl=1)

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체지향프로그래밍-백엔드.png?resize=768,476&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%B1%EC%97%94%EB%93%9C.png?resize=768,476&ssl=1)

위의 예제에서 확인할 수 있듯이, Driver 클래스의 코드는 매우 간단하다. 즉, 매개변수로 자동차나 오토바이 객체를 전달받아 운전하는 것이다. 이렇게 하나의 객체가 다른 객체의 속성과 기능에 접근하여 어떤 기능을 사용할 때, 우리는 **A클래스는 B클래스에 의존**한다 라고 표현한다. 즉, Dirver 클래스와 다른 두 개의 클래스가 서로 직접적인 관계를 가지고 있는데, 이러한 상황을 **객체들 간의 결합도가 높다라고도 표현**한다.

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체-지향-프로그래밍-의존성.png?resize=768,492&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%98%EC%A1%B4%EC%84%B1.png?resize=768,492&ssl=1)

하지만 이렇게 결합도가 높은 상태는 객체 지향적인 설계를 하는 데 매우 불리하다.

지금처럼 자동차나 오토바이만 있는 것이 아니라 수 십, 수 백개 객체와 연결되는 경우를 생각해보면 알 수 있다.

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체-지향-프로그래밍-특징-4.png?resize=768,221&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-4.png?resize=768,221&ssl=1)

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체-지향-프로그래밍-예시.png?resize=768,439&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%98%88%EC%8B%9C.png?resize=768,439&ssl=1)

이런 식으로 코드를 작성하면 한눈에 봐도 코드의 중복이 사라지고, 코드가 훨씬 간결해졌다는 사실을 알 수 있다. 핵심은 drvie() 메서드로 전달되는 매개변수의 타입을 상위 클래스인 인터페이스 타입 Vehicle로 변경한 것이다. 이제 다형성의 세례를 받은 drive() 메서드의 매개변수로 인터페이스를 구현한 객체라면 무엇이든 전달이 될 수 있는 것이다.

![https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/객체-지향-프로그래밍-코드.png?resize=768,393&ssl=1](https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%BD%94%EB%93%9C.png?resize=768,393&ssl=1)

위 그림과 같이 인터페이스를 통해 간접적으로 연결되어 결합도가 낮아졌다. 따라서 Drive 클래스는 더 이상 각각의 클래스 내부의 변경에 휘둘리지 않아도 된다.

하지만 아직 문제가 더 남아있다.

여전히 실행 클래스의 코드에서 객체를 생성할 때, new Car(), new MotorBike() 처럼 객체에 직접적으로 의존하고 있어서, 해당 객체를 다른 개체로 변경할 시 코드의 변경이 불가피하다. 즉, 다시 객체 간 높은 결합도를 보이는 상황이 나타난다. 이러한 문제를 해결하기 위해 등장한 것이 **DI** 라고 부르는 스프링 프레임워크의 핵심적인 개념이다.

정리하면, 객체 지향 프로그래밍은 객체 간 관계와 협력을 설계하는 것인데, 다형성은 그 관계를 보다 유연하고 확장이 용이한 설계가 가능하도록 하는데 핵심적인 역할을 한다는 사실이 중요하다. 또한, 다형성을 제대로 활용하기 위해서 앞서 배웠던 추상화와 상속에 대한 내용들이 함께 존재해야 한다는 사실도 기억해야 한다. 즉, 추상화가 있어야 각 객체들의 역할 정의가 가능하고, 인터페이스는 상위 클래스 - 하위 클래스를 전제하기 때문에 상속에서 배웠던 개념들이 함께 필요하다.

### 4. 캡슐화 (Encapsulation)

캡슈화란 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호하는 것을 말한다.

즉, 서로 관련 있는 데이터와 이를 처리할 수 있는 기능들을 한곳에 모아 관리하는 것이다. 자바 객체 지향 프로그래밍에서 이렇게 캡슐화를 하는 이유로 크게 두 가지를 언급할 수 있다.

- 데이터 보호 : 외부로부터 클래스에 정의된 속성과 기능들을 보호
- 데이터 은닉 : 내부의 동작을 감추고 외부에는 필요한 부분만 노출

자바에서 캡슐화를 구현하기 위한 방법은 크게 두 가지가 있다. 첫 번째는 접근 제어자를 활용하는 것이다. 접근 제어자는 클래스 또는 클래스 내부의 멤버들에 사용되어 해당 클래스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한하는 역할을 한다.

두 번째 방법으로는 getter/setter 메서드이다.