# 프로그래밍 공통

# SOLID

SOLID는 객체 지향 프로그래밍에서 약속된 다섯 가지 설계원칙이다. 이러한 원칙들은 소프트웨어의 **유연성, 확장성, 재사용성** 등을 향상시키는데 중요한 역할을 한다.

## 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

1. 하나의 클래스는 하나의 책임만을 가져야 한다.
2. 한 클래스에 너무 많은 책임이 있으면 코드 변경 시 다른 책임도 함께 변경될 가능성이 높아지기에 유지보수가 어려워진다.

### 단일 책임 원칙을 준수하지 않은 코드

```java
public class User {
    private String name;
    private String email;

    public void save() {
        // save user to database
    }

    public void sendEmail(String subject, String message) {
        // send email to user
    }
}
```

> 위 코드에서는 User 클래스가 저장과 전송 두 가지 책임을 지니고 있다.

### 단일 책임 원칙을 준수한 코드

```java
public class User {
    private String name;
    private String email;

    public void save() {
        // save user to database
    }
}

public class EmailSender {
    public void sendEmail(User user, String subject, String message) {
        // send email to user
    }
}
```

> 위 코드에서는 User, EmailSender 두 가지로 클래스를 분리하여 각각의 클래스가 저장과 전송 기능에 집중할 수 있도록 하였다. 이렇게 클래스를 관리한다면 유지보수와 확장이 용이하게 된다.
>
> ex) User 클래스에 update (유저 정보 업데이트) 메서드 추가

## 2. 개방-페쇄 원칙 (Open-Closed Principle, OCP)

1. 확장에는 열려 있고, 수정에는 닫혀 있어야 한다. (확장가능, 외부수정x)
2. 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있도록 설계 (확장성)

### 개방 폐쇄 원칙을 준수한 코드

```java
public interface PaymentMethod {
    void pay(double amount);
}

public class CreditCardPayment implements PaymentMethod {
    private String cardNumber;
    private String cvv;
    private String expDate;

    public CreditCardPayment(String cardNumber, String cvv, String expDate) {
        this.cardNumber = cardNumber;
        this.cvv = cvv;
        this.expDate = expDate;
    }

    @Override
    public void pay(double amount) {
        // credit card payment implementation
    }
}

public class PaypalPayment implements PaymentMethod {
    private String email;
    private String password;

    public PaypalPayment(String email, String password) {
        this.email = email;
        this.password = password;
    }

    @Override
    public void pay(double amount) {
        // Paypal payment implementation
    }
}

public class Payment {
    private PaymentMethod paymentMethod;

    public Payment(PaymentMethod paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void processPayment(double amount) {
        paymentMethod.pay(amount);
    }
}

public class Main {
    public static void main(String[] args) {
        PaymentMethod paymentMethod = new CreditCardPayment("1234 5678 9012 3456", "123", "01/23");
        Payment payment = new Payment(paymentMethod);
        payment.processPayment(100.0);
    }
}
```

> 위 코드에서는 PaymentMethod 인터페이스를 정의하고, 이를 구현하는 CreditCardPayment와 PaypalPayment 클래스를 작성한다. 이후 Payment 클래스에서 PaymentMethod를 의존성 주입으로 받아 처리하는 방식을 사용한다.

이렇게 하면 새로운 결제 수단을 추가할 때, PaymentMethod 인터페이스를 구현하는 클래스를 작성하면 된다. 기존 코드를 수정하지 않아도 되므로 개방 폐쇄 원칙을 잘 지키고 있는 것이다.

## 3. 리스코프 치환 원칙 (Liskov Subsitution Principle, LSP)

리스코프 치환 원칙은 부모 객체와 이를 상속한 자식 객체가 있을 때, 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다.

객체지향 언어에서는 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며, 이를 토대로 확장할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다.

리스코프 치환 원칙은 옳바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.

### 리스코프 치환 원칙을 위배한 코드

```java
public class Rectangle
{
    protected int width;
    protected int height;
    
   
    public int getWidth()
    {
        return width;
    }
    
    public int getHeight()
    {
        return height;
    }
    
   
    public void setWidth(int width)
    {
        this.width = width;
    }
    
   
    public void setHeight(int height)
    {
        this.height = height;
    }
    
   
    public int getArea()
    {
        return width * height;
    }
}
```

Rectangle은 직사각형을 구현한 객체다. 너비와 높이를 지정, 반환할 수 있으며, 지정된 값을 통해 자신의 넓이를 계산할 수 있다.

정사각형 역시 넓게 보면 직사각형의 한 종류이니, 직사각형을 상속하여 정사각형 객체를 빠르게 만들 수 있다고 생각하고 진행하자.

```java
public class Square extends Rectangle
{
  
    @Override
    public void setWidth(int width)
    {
        super.setWidth(width);
        super.setHeight(getWidth());
    }
    
   
    public void setHeight(int height)
    {
        super.setHeight(height);
        super.setWidth(getHeight());
    }
}
```

위 처럼 정사각형 객체 Square 를 Rectangle의 상속을 통해 쉽게 구현할 수 있다.

정사각형의 경우 직사각형과 달리 너비와 높이가 같으니, 너비나 높이를 지정하면 그에 맞게 너비와 높이를 모두 일치 시켜주도록 오버라이딩을 수행했다.

```java
public class Main
{
    
    public static void main(String[] args)
    {
        Rectangle rectangle = new Rectangle();
        rectangle.setWidth(10);
        rectangle.setHeight(5);
        
        System.out.println(rectangle.getArea());
    }
}
// 정답 50

public class Main
{
    
    public static void main(String[] args)
    {
        Rectangle rectangle = new Square();
        rectangle.setWidth(10);
        rectangle.setHeight(5);
        
        System.out.println(rectangle.getArea());
    }
}
// 정답 25
```

리스코프 치환 원칙에 의하면, 자식 객체는 부모 객체를 완전히 대체할 수 있다고 했으므로, Rectangle을 상속받은 Square로 대체하여 넓이를 구해도 같은 값이 나와야 하지만 수학적으로 직사각형과 정사각형은 상속관계가 절대 될 수 없다.

### 리스코프 치환 원칙을 준수한 코드

```java
public class Shape {

    public int width;
    public int height;

    // 너비 반환, Width Getter
    public int getWidth() {
        return width;
    }
    // 너비 할당, Width Setter
    public void setWidth(int width) {
        this.width = width;
    }

    // 높이 반환, Height Getter
    public int getHeight() {
        return height;
    }
    // 높이 할당, Height Setter
    public void setHeight(int height) {
        this.height = height;
    }

    // 사각형 넓이 반환
    public int getArea() {
        return width * height;
    }
}
//직사각형 클래스
public class Rectangle extends Shape {

    public Rectangle(int width, int height) {
        setWidth(width);
        setHeight(height);
    }

}

//정사각형 클래스
public class Square extends Shape{
    
    public Square(int length) {
        setWidth(length);
        setHeight(length);
    }
    
}
public class Main {
    public static void main(String[] args) {
    
        Shape rectangle = new Rectangle(10, 5);
        Shape square = new Square(5);
        
        System.out.println(rectangle.getArea());
        System.out.println(square.getArea());
    }
}
```

즉, 리스코프 치환 원칙은 상속되는 객체는 반드시 부모 객체를 완전히 대체할 수 있어야 한다고 권고한다.

## 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

ISP 원칙이란 범용적인 인터페이스 보다는 클라이언트가 실제로 사용하는 인터페이스를 만들어야 한다는 의미로, 인터페이스를 사용에 맞게 끔 각기 분리해야한다는 설계 원칙이다.

만약 인터페이스의 추상 메서드들을 범용적으로 이것저것 구현한다면, 그 인터페이스를 상속받은 클래스는 자신이 사용하지 않는 인터페이스 마저 억지로 구현해야 하는 상황이 올 수도 있다.

- 쓰지 않는 메서드를 구현하고 메서드 내부를 빈 공간으로 두거나 예외 처리를 하는 것은 상당히 낭비이다!

또한 사용하지도 않는 인터페이스의 추상 메서드가 변경된다면 클래스에서도 수정이 필요하게 된다.

즉, 인터페이스 분리 원칙이란 인터페이스를 잘게 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이다.

따라서 아래 그림과 같이 Pet 인터페이스를 좀 더 잘게 나눔으로써 각 애완동물 클래스의 역활과 맞게 상속 시켜줌으로써, 클래스의 기능을 쉽게 파악할 수 있다는 이점을 얻을 수 있게 된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99363d3c-ee0b-4561-8998-9527c66e109e/Untitled.png)

인터페이스 분리 원칙은 마치 단일 책임 원칙과 비슷하게 보이는데, SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조한다고 말할 수 있다.

다만 유의할 점은 인터페이스는 클래스와 다르게 추상화이기 때문에 여러 개의 역할을 가지는 데에 있어 제약이 없긴 하다.

즉, SRP 원칙의 목표는 클래스 분리를 통하여 이루어진다면, ISP 원칙은 인터페이스 분리를 통하여 이루어진다고 볼 수 있다.

> **인터페이스 분리는 한번만**
>
> ISP 원칙의 주의해야 할점은 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말라는 점이다.
>
> 이미 구현되어 있는 프로젝트에 또 인터페이스들을 분리한다면, 이미 해당 인터페이스를 구현하고 있는 온갖 클래스들과 이를 사용하고 있는 클라이언트(사용자)에서 문제가 일어날 수 있기 때문이다.
>
> 본래 인터페이스라는 건 **한번 구성하였으면 왠만해선 변하면 안되는 정책**같은 개념이다.
>
> 따라서 처음 설계부터 기능의 변화를 생각해두고 인터페이스를 설계해야 하는데, 이는 현실적으로 참 힘든 부분이며 역시 개발자의 역량에 달렸다.

## 5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)

1. 추상화에 의존해야지, 구체화에 의존하면 안된다
2. 추상 인터페이스나 추상 클래스와 같은 상위 수준 모듈에 의존해야 한다

### 의존 역전 원칙을 준수하지 않은 코드

```java
public class LightBulb {
    public void turnOn() {
        // Light bulb turns on
    }

    public void turnOff() {
        // Light bulb turns off
    }
}

public class LightSwitch {
    private LightBulb lightBulb;

    public LightSwitch() {
        this.lightBulb = new LightBulb();
    }

    public void press() {
        if (lightBulb != null) {
            lightBulb.turnOn();
        }
    }
}
```

> 위 코드에서 LightSwitch 클래스가 LightBulb 클래스에 의존하고 있다. 즉, LightSwitch 클래스는 LightBulb 클래스가 제공하는 기능을 직접 사용하고 있다. 이는 의존 역전 원칙을 위배하는 코드이다
>
> 클래스 간의 직접적인 결합을 맺고 있기 때문 (상위 모듈 이용 지향)

```java
public interface Switchable {
    void turnOn();
    void turnOff();
}

public class LightBulb implements Switchable {
    @Override
    public void turnOn() {
        // Light bulb turns on
    }

    @Override
    public void turnOff() {
        // Light bulb turns off
    }
}

public class LightSwitch {
    private Switchable device;

    public LightSwitch(Switchable device) {
        this.device = device;
    }

    public void press() {
        if (device != null) {
            device.turnOn();
        }
    }
}
```

> Siwthable 인터페이스에만 의존하도록 변경되었다. 이렇게함으로써, LightSwitch 클래스는 Switchable 인터페이스를 구현한 다른 클래스들과도 호환되어 사용될 수 있게 된다.

------

# 절차지향 프로그래밍 vs 객체지향 프로그래밍

- 절차지향 프로그래밍
  - 물이 위에서 아래로 흐르는 것처럼 순차적인 처리를 중요시하는 프로그래밍 기법 (대표적으로 C언어)
  - 컴퓨터의 처리구조와 유사하여 실행속도가 빠르다
  - 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다
- 객체지향 프로그래밍
  - 실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법 (대표적으로 Java)
  - 추상화, 상속, 다형성, 캡슐화 같은 기법을 이용할 수 있다.
  - 절차지향 언어보다 실행속도가 느리다

------

# RESTful API

RESTful API란 REST를 기반으로 만들어진 API이다. CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식이다

## REST

REST(Representational State Transfer = 대표적인 상태 전달)의 약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미한다.

즉, REST란

1. HTTP URI (Uniform Resource Indetifier) 를 통해 자원을 명시하고
2. HTTP Method (POST, GET, PUT, DELETE, PATCH 등)를 통해
3. 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미한다.

> REST는 자원 기반 구조 (ROA, Resource Oriented Architecture) 설계의 중심에 Resource 가 있고, HTTP Method 를 통해 Resource를 처리하도록 설계된 아키텍처를 의미한다
>
> ! 웹 사이트의 이미지, 텍스트 DB 내용 등의 모든 자원에 대한 고유한 ID인 HTTP URI를 부여한다

> **CRUD Operation 이란?**
>
> CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능으로 REST에서는 다음과 같다.
>
> Create : 데이터 생성 (POST)
>
> Read : 데이터 조회 (GET)
>
> Update : 데이터 수정 (PUT, PATCH)
>
> Delete : 데이터 삭제 (DELETE)

### REST 구성 요소

1. 자원 : HTTP URI
   1. 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재
   2. 자원을 구별하는 ID는 ‘localhost:8080/map/view’ 와 같은 HTTP URI이다
   3. Client 는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다
2. 자원에 대한 행위 : HTTP Method
3. 자원에 대한 행위의 내용 (Representation) : HTTP Message Pay Load
   1. REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태로 나타내어 질 수 있다. 현대에는 JSON이 대세

### REST의 특징

1. Server-Client 구조
2. Stateless 무상태
3. Cacheable 캐시 처리 가능
4. Layered System 계층화
5. Uniform Interface 인터페이스 일관성

### 장점

- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다
- HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해준다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다
- Hypermedia API 의 기본을 충실히 지키면서 범용성을 보장한다
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다
- 서버와 클라이언트의 역할을 명확하게 분리한다

### 단점

- 표준 자체가 존재하지 않아 정의가 필요하다
- HTTP Method 형태가 제한적이다
- 브라우저를 통해 테스할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL 보다 Header 정보의 값을 처리해야 하므로 전문성이 요구된다

## REST API 설계 예시

REST의 원리를 따르는 API를 의미한다. 올바르게 설계하기 위한 규칙들을 알아보자.

1. URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다

**Bad Example** http://weonest.com/Running/

**Good Example** http://weonest.comrun/ ****

1. 마지막에 슬래시를 포함하지 않는다

**Bad Example** http://weonest.com/test/ ****

**Good Example** http://weonest.com/test

1. 언다바 대신 하이픈을 사용한다

**Bad Example** http://weonest.com/test_blog

**Good Example** http://weonest.com/test-blog ****

1. 파일확장자는 URI에 포함하지 않는다

**Bad Example** http://weonest.com/photo.jpg ****

**Good Example** http://weonest.com/photo ****

1. 행위를 포함하지 않는다

**Bad Example** http://weonest.com/delete-post/1 ****

**Good Example** http://weonest.com/post/1 ****

------

## 프레임워크와 라이브러리 차이

- 프레임워크 : 전체적인 흐름을 자체적으로 제어
- 라이브러리 : 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다 쓸 수 있다

프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라진다. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전 (IoC)이 적용된다

------

## 동기와 비동기의 차이

- 동기 (Synchronous) 방식
  - 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
  - 순서에 맞추어 진행되기 때문에 제어하기 쉽다
  - 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어진다
- 비동기 (Asynchronous) 방식
  - 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
  - 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있따
  - 작업이 완료도면 결과를 제어하기 어렵다

------

## 함수형 프로그래밍

함수형 프로그래밍의 가장 큰 특징 두 가지는 `immutable data`와 `first class citizen으로서의 function`이다.

### immutable vs mutable

`immutable` 이란 말 그대로 변경 불가능함을 의미한다. `immutable`객체는 객체가 가지고 있는 값을 변경할 수 없는 객체를 의미하여 값이 변경될 경우, 새로운 객체를 생성하고 변경된 값을 주입하여 반환해야 한다. 이와는 달리 `mutable` 객체는 해당 객체의 값이 변경될 경우 값을 변경한다.

```java
String str = Hello World

public void foo(str) {
	str.substring(0,2);
}
```

foo 함수를 동작시키더라도 원본값 (str) 이 변하지 않음을 통해 불변성을 알 수 있음. 이는 str의 값을 그대로 복사하여 함수에게 넘겨주는 방식 (값에 의한 호출)이기 때문.

즉, 새로운 스택 프레임에 foo() 함수가 작동된 값이 담기는 것

### fisrt-class-citizen

함수형 프로그래밍 패러다임을 따르고 있는 언어에서의 함수는 **일급객체로** 간주된다. 일급 객체라 함은 다음의 3가지 조건을 충족한다고 할 수 있다.

- 변수나 데이터에 할당 할 수 있어야 한다.
- 객체의 인자로 넘길 수 있어야 한다.
- 객체의 리턴값으로 리턴 할 수 있어야 한다.

**하지만 Java는 함수형 프로그래밍 패러다임을 따르고 있으면서도 Java의 함수는 일급객체로 분류될 수 없는데, 이를 예시를 통해 알아보자.**

1. 변수나 데이터에 할당 할 수 있어야 한다.

```java
public class java {
	public static void test() {
			System.out.print("java");
		}
	public static void main(String[] args) {
			System.out.print("java");
		//		Object a = test; 불가능
		//    Test test = new Test(); 선언 후 가능
		}
}
```

Java는 `*test*` 함수를 변수 `a`에 할당 할 수 없다.

1. 객체의 인자로 넘길 수 있어야 한다.

```java
public class Main {
 
    public static void hello(){
        System.out.println("Hello World");
    }
    
    public static void print(Object func) {
    	func();
    }
 
    public static void main(String[] args) {
		print((Object) hello) // !! static 메서드를 함수 매개변수로 전달 불가능
    }
}
// JS에서는 가능
function call(func, name) {
  func(name);
}

function hi(name) {
  console.log(`Hi, ${name}!`);
}

call(hi, "Thomas");

// call 함수는 매개변수로 함수, 이름을 받는다.
// hi라는 함수를 선언했고, 이 함수는 매개변수로 이름을 받는다.
// call 함수를 호출하면서, 인수로 hi함수와 "Thomas"라는 이름을 인수로 전달한다.
// 이 때 주의할 점으로, hi()에서 ()를 제외하고 전달해야 한다.
// hi()는 함수를 즉시 실행하는 명령으로, hi()를 전달하면 의도와 다른 hi함수의 return값이 전달되게 된다.
```

1. 객체의 리턴값으로 리턴 할 수 있어야 한다.

```java
function hello() {
  function hi() {
    console.log("hi");
  }
  return hi;
}

const a = hello();
a();

// 다음과 같이 hello 함수 내에서 hi라는 함수를 만들고, hi함수를 반환할 수 있다.
// hello 함수를 실행한 결과, hi함수가 반환되는데 이 리턴값을 a라는 변수에 넣어준다.
// 그리고 a()로 hi함수를 실행할 수 있다.
```

역시 Java 메소드의 리턴값으로 메소드 자체를 반환 하는 행위는 불가능하다. 반면에 JS는 클로저 기법을 통해 구성할 수 있다.

Java는 이러한 단점을 람다 표현식 (Lambda Expression)을 통해 보완하고 있다. Java의 **람다식** 혹은 **익명 클래스**는 변수나 매개변수에 할당 할 수 있고, 리턴 값으로도 사용할 수 있기 때문에 일급 객체의 요건을 충족한다.

```java
**// 변수나 데이터에 담을 수 있다.**
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        Consumer<String> c = (t) -> System.out.println(t); // 람다식을 인터페이스 타입 변수에 할당
        c.accept("Hello World");
    }
}

**// 함수의 파라미터로 전달 할 수 있다.**
import java.util.function.Consumer;

public class Main {
    // 메소드 매개변수로 람다 함수를 전달
    public static void print(Consumer<String> c, String str) {
        c.accept(str);
    }

    public static void main(String[] args) {
        print((t) -> System.out.println(t) ,"Hello World");
    }
}

**// 함수의 리턴값으로 사용 할 수 있어야 한다.**
public class Main {

    public static Object hello(){
        System.out.println("Hello World");
        return new Object() { // 익명 클래스 객체를 리턴값으로
            public String toString() {
                return "Hello World 22";
            }
        };
    }

    public static void main(String[] args) {
        Object obj = hello();
        System.out.println(obj.toString());
    }
}
```

------

## Parameter 와 Argument의 차이

- Parameter : 함수를 선언할 때 사용된 변수
- Argument : 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값