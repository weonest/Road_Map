# Hash

------

https://pangtrue.tistory.com/291

## 해쉬는 왜 생겼을까?

가장 기본적인 자료구조인 배열의 경우 내부 인덱스를 이용하여 자료의 검색이 한 번에 이루어지기 때문에 빠른 검색 속도를 보이는 반면 데이터의 **삽입, 삭제 시** 많은 데이터가 밀리거나 빈 자리를 채우기 위해 이동해야 하므로 많은 시간이 소요된다.

또, LinkedList는 삽입, 삭제 시 인근 노드들의 참조값만 수정해줌으로써 빠른 처리가 가능했지만 처음, 마지막 노드 이외의 위치에서 데이터를 삽입, 삭제, 검색할 경우에는 해당 노드를 찾기 위하여 처음부터 순회검색을 해야하기 때문에 데이터의 수가 많아질 수록 효율이 떨어질 수 밖에 없는 구조였다.

이를 극복하기 위해 제시된 방법이 해쉬이다.

해시 함수는 **임의의 길이**를 갖는 임의의 데이터에 대해 **고정된 길이**의 데이터로 매핑하는 함수이다. 이때, 매핑하기 전 입력 데이터의 값을 키(Key), 매핑 후 출력 데이터의 값을 해시코드(HashCode), 매핑하는 과정 자체를 해싱(Hashing)이라 부른다.

해시의 특징은 다음과 같다.

1. 동일한 입력 값에 대해서는 **항상 동일한 출력 값**이 보장된다
2. 출력 데이터 값을 가지고 원본 입력 데이터의 값을 알아낼 수 없다
3. 일반적으로 해시 함수는 그리 복잡하지 않은 알고리즘으로 구현되기 때문에 CPU, 메모리 자원을 크게 소비하지 않는다
4. 입력 값의 범위보다 출력 값의 범위가 좁기 때문에 다른 입력 데이터에 대해 **드물게 동일한 출력 값이 나올 수 있다. (충돌)**

해시를 활용한 자료구조의 **검색이 빠른 이유는** 해싱을 통해 만든 **해시코드를 내부적으로 배열의 인덱스로 활용**하기 때문이다. 별도의 정렬을 거치지 않고도 찾고자 하는 데이터의 인덱스를 해싱을 통해 바로 추출해낼 수 있다는 게 포인트이다. 반대로, 해시코드를 인덱스로 활용하여 자료가 분산되기 때문에 어떠한 기준으로 **정렬하고자 할 때는 적합하지 않다.**

> 즉, for 문을 돌려 인덱스 하나하나를 찾아가며 검색하는 것이 아니라는 것인데,
>
> 예시로 {1, 5, 7, 14}에서 7을 찾는 과정을 보자면, 7을 찾기 위해 Hashing을 진행하여 해시코드를 얻고 {1, 5, 7, 14}

### 충돌방지와 회피

해시 함수에서 입력값의 범위에 비해 출력값의 범위가 좁기 때문에 각기 다른 입력 데이터에 대해 동일한 출력값이 나오는, 이른바 ‘**충돌**’이 발생할 수 있다. 해시를 활용한 자료구조는 해싱을 거쳐 나온 **해시코드를 배열의 인덱스**로 활용한다고 했는데, 충돌이 발생하면 값이 저장해야할 **인덱스 위치가 겹치는 문제가 발생하게 된다** .따라서, 이를 해결하기 위해 일반적으로 해당 버킷에 데이터가 이미 있다면, **체인처럼 노드를 추가하여 다음 노드를 가리키는 방식**(연결리스트)으로 구현한다.

쉽게 말해, 각각의 버킷에 여러 데이터가 저장될 수 있으니, 하나의 버킷 자체도 배열로 구성하는 것

https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/xlEWs/btqR6vhZ75K/iaszAk9Fsy55G6w1XKWyZk/img.png

- 이와 같은 구조로 충돌이 100% 안전하다고 볼 수는 없다. 모든 키가 같은 해시 값으로 매핑이 될 경우 데이터를 액세스 할 때 비효율성이 커지고, 보안이 취약해져 굳이 해시를 도입해 데이터를 관리할 이유가 없어지기 때문. **그렇기에 충돌이 해시값 전체에 걸쳐 균등하게 발생하도록 하는 것도 중요**