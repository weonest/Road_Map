# 컴파일 과정

------

https://gyoogle.dev/blog/computer-language/Java/컴파일 과정.html

우선 자바는 OS에 독립적인 특징을 가지고 있다. 그것이 가능한 이유는 JVM (Java Vitual Machine) 덕분이다. 그렇다면 JVM의 어떠한 기능 때문에 OS에 독립적으로 실행시킬 수 있는지 자바 컴파일 과정을 통해 알아보도록 하자

![http://tcpschool.com/lectures/img_java_programming.png](http://tcpschool.com/lectures/img_java_programming.png)

https://t1.daumcdn.net/cfile/tistory/991D064B5AE999D512

## 자바 컴파일 순서

1. 개발자가 자바 **소스코드(.java)**를 작성한다

2. 자바 컴파일러가 자바 소스파일을 컴파일 한다. 이때 나오는 파일은 자바 **바이트 코드(.class)** 파일로 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드이다.

3. 컴파일된 바이트 코드를 **JVM의 클래스로더**에게 전달한다

4. 클래스 로더는 동적로딩(Dynamic Loading) 을 통해 필요한 클래스들을 로딩 및 링크하여 **런타임 데이터 영역 (Runtime Data Area**) , **즉 JVM의 메모리에 올린다**

   ### 클래스 로더 세부 동작

   1. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드한다
   2. 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사
   3. 준비 : 클래스가 필요로 하는 메모리를 할당한다 (필드, 메서드, 인터페이스 등등)
   4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다
   5. 초기화 : 클래스 변수들을 적절한 값으로 초기화 (static 필드)

5. **실행 엔진은 JVM 메모리**에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 이때, 실행 엔진은 두 가지 방식으로 변경한다

   1. 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점
   2. JIT (Just In Time Compiler) : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식 보다 빠르다

### JVM의 역할은?

바이트 코드로 변환된 코드를 클래스 로더가 JVM의 메모리에 올리면 **JVM의 실행 엔진인 인터프리터나 JIT 컴파일러가 해석하고 실행하는 역할**. 즉, JVM은 다른 프로그램을 실행시키는 것이 목적으로

1. 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하고
2. 프로그램 메모리를 관리하고 최적화 한다