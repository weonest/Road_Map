# 캡슐화와 은닉화의 차이

------

https://dokdogalmaegi.tistory.com/48

## 캡슐화 (Encapsulation)

객체지향 패러다임 중 하나인 캡슐화는 중요한 데이터를 보존, 보호하는 것이다. 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말하기도 한다.

```java
public People {
    // 멤버변수를 private로 선언 해줌과 동시에 은닉화 발생
    private String name;
    private int age;

    // 캡슐화가 발생하지 않음.
    public String **getName**() {
        return this.name;
    }
    public void **setName**(String name) {
        this.name = name;
    }

    // 캡슐화가 발생하지 않음.
    public int getAge() {
        // ...만 19세 이상인가를 체크하는 코드
        return this.age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}
```

위 코드에서 멤버 변수는 private 접근자를 사용해 중요한 데이터를 바로 접근하지 못하도록 사용했지만, 이름과 나이를 가져오는 메서드인 **getter, setter에서 메서드 명에 변수 이름**을 노출 시키면서 완벽한 캡슐화를 이루지 못했다.

그럼 어떻게 작성해야만 정보 은닉화와 캡슐화가 적용될까?

```java
public People {
    // 멤버변수를 private로 선언 해줌과 동시에 은닉화 발생
    private String name;
    private int age;

    // 속성 age의 getter와 setter와 다르게 이름에서 어떤 속성에 getter인지 setter인지 명확히 알 수 있어 완벽한 캡슐화라고 할 수 없다.
    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }

    // 메서드 명을 간단하게 get, set이 아닌 이로 인해 발생하는 일을 생각해 추상적으로 명명하는 것이 캡슐화에 더 가까운 명명이다.
    // 이 서비스는 성인인지 아닌지에 따라 다른 서비스를 제공하여 나이를 체크해야하는 서비스라고 생각했을 때 메서드 명이다.
    public int checkAdult() {
        ...만 19세 이상인가를 체크하는 코드
        return this.age;
    }
    public void changeAge(int age) {
        this.age = age;
    }
```

속성 age의 getter, sette는 이 값을 불러올 때 어떠한 정보를 얻어야 하는가에 대해 한 단계 더 생각해 메서드 명을 보다 추상적으로 명명할 수 있었다.

하지만 여전히 name 속성은 getName, setName과 같이 어떤 속성, 역할을 하는지 명확히 보여 완벽한 캡슈로하라고 볼 수 없다. 보다 쉽게 풀자면 은닉화는 외부에서 객체의 속성을 함부로 접근하지 못하도록 하는 것을 일컫고, 캡슐화는 메서드 안에서 어떠한 일이 일어나고 있는지 모르게 해야한다는 것이다.

**이렇듯 속성의 접근을 제어하는 것을 은닉화, 메서드의 내부를 알지 못하도록 하는 것을 캡슐화라고 한다**.