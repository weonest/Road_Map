# 논리 연산자

## || (OR)

인수 중 하나라도 true면 true를 반환하고, 그렇지 않으면 false를 반환한다.

```jsx
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false

if (1 || 0) { // if( true || false ) 와 동일하게 동작합니다.
  alert( 'truthy!' );
}
```

### 첫 번째 truthy를 찾는 OR 연산자 ‘||’

OR 연산자와 피연산자가 여러 개인 경우:

```jsx
result = value1 || value2 || value3;
```

이때, OR `||`연산자는 다음 순서에 따라 연산을 수행한다.

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
- 각 피연산자를 불린형으로 변환한다. 변환 후 그 값이 true이면 연산을 멈추고 해당 피연산자의 **변환 전** 원래 값을 반환한다.
- 피연산자 모두를 평가한 경우 (모든 피연산자가 false로 평가되는 경우)엔 마지막 피연산자를 반환한다.

여기서 핵심은 반환 값이 형 변환을 하지 않은 원래 값이라는 것이다.

정리해 보자면 이렇다. OR `"||"` 연산자를 여러 개 체이닝 하면 첫 번째 truthy를 반환한다. 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환한다.

```jsx
alert( 1 || 0 ); // 1 (1은 truthy임)

alert( null || 1 ); // 1 (1은 truthy임)
alert( null || 0 || 1 ); // 1 (1은 truthy임)

alert( undefined || null || 0 ); // 0 (모두 falsy이므로, 마지막 값을 반환함)
```

이런 OR 연산자의 추가 기능을 이용하면 여러 용도로 OR 연산자를 활용할 수 있다.

1. **변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기**

   `firstName`, `lastName`, `nickName` 이란 변수가 있는데 이 값들은 모두 옵션 값이라고 해보자. OR `||` 을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있다.

   ```jsx
   let firstName = "";
   let lastName = "";
   let nickName = "바이올렛";
   
   alert( firstName || lastName || nickName || "익명"); // 바이올렛
   ```

   모든 변수가 falsy이면 “익명”이 출력되었을 것.

2. **단락 평가**

   OR 연산자 `||`가 제공하는 또 다른 기능은 ‘단락 평가(short circuit evaluation)’이다.

   위에서 설명한 바와 같이 OR은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 **나머지 값들은 건드리지 않은 채 평가를 멈춘다**. 이런 프로세스를 ‘단락 평가’라고 한다.

   단락 평가의 동작 방식은 두 번째 피연산자가 변수 할당과 같은 부수적인 효과를 가지는 표현식 일 때 명확히 볼 수 있다.

   ```jsx
   true || alert("not printed");
   false || alert("printed");
   ```

   첫 번째 줄의 `||`연산자는 true를 만나자마자 평가를 멈추기 때문에 `alert`가 실행되지 않는다. 단락 평가는 연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때 자주 쓰인다.

## && (AND)

두 개의 엠퍼샌드를 연달아 쓰면 AND 연산자 `&&`를 만들 수 있다.

전통적인 프로그래밍에서 AND 연산자는 두 피연산자가 모두가 참일 때 true를 반환한다. 그 외의 경우는 false를 반환한다.

```jsx
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

OR 연산자와 마찬가지로 AND 연산자의 피연산자도 타입에 제약이 없다.

```jsx
if (1 && 0) { // 피연산자가 숫자형이지만 논리형으로 바뀌어 true && false가 됩니다.
  alert( "if 문 안에 falsy가 들어가 있으므로 alert창은 실행되지 않습니다." );
}
```

### 첫 번째 falsy를 찾는 AND 연산자 ‘&&’

AND 연산자 `&&`는 아래와 같은 순서로 동작한다.

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가.
- 각 피연산자는 불린형으로 변환. 변환 후 값이 false면 평가를 멈추고 해당 피연산자의 **변환 전 원래 값을 반환**
- 피연산자 모두가 평가되는 경우 (모든 피연산자가 true로 평가되는 경우)엔 마지막 피연산자가 반환.

정리해 보자면 이렇습니다. AND 연산자는 첫 번째 falsy를 반환합니다. 피연산자에 falsy가 없다면 마지막 값을 반환합니다.

위 알고리즘은 OR 연산자의 알고리즘과 유사합니다. 차이점은 AND 연산자가 첫 번째 *falsy*를 반환하는 반면, OR은 첫 번째 *truthy*를 반환한다는 것입니다.

```jsx
// 첫 번째 피연산자가 truthy이면,
// AND는 두 번째 피연산자를 반환합니다.
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 첫 번째 피연산자가 falsy이면,
// AND는 첫 번째 피연산자를 반환하고, 두 번째 피연산자는 무시합니다.
alert( null && 5 ); // null
alert( 0 && "아무거나 와도 상관없습니다." ); // 0
```

> ! `&&`의 우선순위가 `||`보다 높다. 따라서 `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작한다.

> **`if`를 ||나 &&로 대체하지 마세요.** 어떤 개발자들은 AND 연산자 `&&`를 `if`문을 ‘짧게’ 줄이는 용도로 사용하곤 합니다.

## ! (NOT)

NOT 연산자는 인수를 하나만 받고, 다음 순서대로 연산을 수행합니다.

1. 피연산자를 불린형(`true / false`)으로 변환합니다.
2. 1에서 변환된 값의 역을 반환합니다.

예시:

```jsx
alert( !true ); // false
alert( !0 ); // true
```

NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환할 수 있습니다.

```jsx
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

이때, 첫 번째 NOT 연산자는 피연산자로 받은 값을 불린형으로 변환 후 이 값의 역을 반환하고, 두 번째 NOT 연산자는 첫 번째 NOT 연산자가 반환한 값의 역을 반환한다. 이렇게 NOT를 연달아 사용하면 특정 값을 불린형으로 변환할 수 있다.

참고로 내장 함수 `Boolean`을 사용하면 `!!`을 사용한 것과 같은 결과를 도출할 수 있다.

```jsx
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

`NOT`연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||`보다 먼저 실행된다.



문제

얼럿 창엔 `1`, `2`가 차례대로 출력됩니다.

```jsx
alert( alert(1) || 2 || alert(3) );
```

`alert` 메서드는 값을 반환하지 않습니다. 즉, `undefined`를 반환하죠.

1. 첫 번째 OR `||` 은 왼쪽 피연산자인 `alert(1)`를 평가합니다. 이때 첫 번째 얼럿 창에 `1`이 출력되죠.
2. `alert`메서드는 `undefined`를 반환하기 때문에, OR 연산자는 다음 피연산자를 평가하게 됩니다. truthy를 찾기 위해 말이죠.
3. 두 번째 피연산자(오른쪽 피연산자)인 `2`는 truthy이기 때문에 실행이 멈추고 `2`가 반환됩니다. 반환된 값 `2`는 제일 바깥 `alert`의 피연산자가 되어 두 번째 얼럿창에 출력됩니다.

평가가 `alert(3)`까지 진행되지 않기 때문에 `3`은 출력되지 않습니다.