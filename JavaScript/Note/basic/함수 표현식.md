# 함수 표현식

```jsx
let sayHi = function() {  // sayHi 변수에 함수 저장
  alert( "Hello" );
};
 
let func = sayHi;  // fucn 변수에 sayHi 함수 복사
// ...
```

> **끝에 세미 콜론?**
>
> 함수 표현식의 끝에 왜 세미 콜론이 붙는지 의문이 들 수도 있다. 함수 선언문에는 세미 콜론이 없는데 말이다.
>
> ```jsx
> function sayHi() {
>   // ...
> }
> 
> let sayHi = function() {
>   // ...
> };
> ```
>
> 이유는 간단하다.
>
> - 중괄호로 만든 코드 블록 끝엔 `;`이 없어도 된다.
> - 함수 표현식은 `let sayHi = ...;`과 같은 구문 안에서 값의 역할을 한다. 코드 블록이 아니고 값처럼 취급 되어 변수에 할당된다. > 세미 콜론 필요

## 콜백 함수

함수를 값처럼 전달하는 예시, 함수 표현식에 관한 예시를 좀 더 살펴보겠다.

매개변수가 3개 있는 함수, `ask(question, yes, no)`를 작성해보겠습니다.

함수는 반드시 `question(질문)`을 해야 하고, 사용자의 답변에 따라라 `yes()` 나 `no()`를 호출합니다.

```jsx
*function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}*function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);
```

이렇게 함수를 작성하는 방법은 실무에서 아주 유용하게 쓰인다. 면대면으로 질문하는 것보다 위처럼 컨펌창을 띄워 질문을 던지고 답변을 받으면 간단하게 설문조사를 진행할 수 있다.

**함수 `ask`의 인수, `showOk`와 `showCancel`은 \*콜백 함수\* 또는 \*콜백\*이라고 불립니다.**

함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것이 콜백 함수의 개념이다. 위 예시에선 사용자가 "yes"라고 대답한 경우 `showOk`가 콜백이 되고, "no"라고 대답한 경우 `showCancel`가 콜백이 된다.

아래와 같이 함수 표현식을 사용하면 코드 길이가 짧아집니다.

```jsx
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);*
```

`ask(...)` 안에 함수가 선언된 게 보이나? 이렇게 이름 없이 선언한 함수는 *익명 함수(anonymous function)* 라고 부른다. 익명 함수는 (변수에 할당된 게 아니기 때문에) `ask` 바깥에선 접근할 수 없다. 위 예시는 의도를 가지고 이렇게 구현하였기 때문에 바깥에서 접근할 수 없어도 문제가 없다.

자바스크립트를 사용하다 보면 콜백을 활용한 코드를 아주 자연스레 만나게 된다. 이런 코드는 자바스크립트의 정신을 대변한다.

## 함수 표현식 vs 함수 선언문

**함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때 부터 해당 함수를 사용할 수 있다.**

```jsx
**sayHi("John"); // error!**

let sayHi = function(name) {  // (*) 마술은 일어나지 않습니다.
  alert( `Hello, ${name}` );
}; // 동작 x
```

**함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있다.**

```jsx
**sayHi("John"); // Hello, John**

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

스크립트 실행 준비 단계에서 생성되기 때문에, 스크립트 내 어디에서든 접근할 수 있다.

**엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근하지 못한다.**

예시를 보자. 런타임에 그 값을 알 수 있는 변수 `age`가 있고, 이 변수의 값에 따라 함수 `welcome()` 을 다르게 정의해야 하는 상황이다. 그리고 함수 `welcome()`은 나중에 사용해야 하는 상황이라고 가정해 보자.

함수 선언문을 사용하면 의도한 대로 코드가 동작하지 않는다.

```jsx
let age = prompt("나이를 알려주세요.", 18);

// 조건에 따라 함수를 선언함
if (age < 18) {

  function welcome() {
    alert("안녕!");
  }

} else {

  function welcome() {
    alert("안녕하세요!");
  }

}

// 함수를 나중에 호출합니다.
**welcome(); // Error: welcome is not defined**
```

함수 선언문은 함수가 선언된 코드 블록 안에서만 유효하기 때문에 이런 에러가 발생한다.

또 다른 예시를 보자.

```jsx
let age = 16; // 16을 저장했다 가정합시다.

if (age < 18) {
  welcome();               // \\   (실행)
                           //  |
  function welcome() {     //  |
    alert("안녕!");        //  |  함수 선언문은 함수가 선언된 블록 내
  }                        //  |  어디에서든 유효합니다
                           //  |
  welcome();               // /   (실행)

} else {

  function welcome() {
    alert("안녕하세요!");
  }
}

// 여기는 중괄호 밖이기 때문에
// 중괄호 안에서 선언한 함수 선언문은 호출할 수 없습니다.

welcome(); // Error: welcome is not defined
```

그럼 `if`문 밖에서 `welcome` 함수를 호출할 방법은 없을까? `if`**문 밖에서** 선언한 변수에 함수 표현식으로 만든 함수를 할당하면 된다.

함수 표현식을 사용하면 가능하다.

```jsx
let age = prompt("나이를 알려주세요.", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("안녕!");
  };

} else {

  welcome = function() {
    alert("안녕하세요!");
  };

}

welcome(); // 제대로 동작합니다.
```

물음표 연산자 `?`를 사용하면 좀 더 단순화할수 있다.

```jsx
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  function() { alert("안녕!"); } :
  function() { alert("안녕하세요!"); };

welcome(); // 제대로 동작합니다.
```

## 요약

- 함수는 값입니다. 따라서 함수도 값처럼 할당, 복사, 선언할 수 있습니다.
- “함수 선언(문)” 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 됩니다.
- “함수 표현식” 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 됩니다.
- 함수 선언문은 코드 블록이 실행되기도 전에 처리됩니다. 따라서 블록 내 어디서든 활용 가능합니다.
- 함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어집니다.

함수를 선언해야 한다면 함수가 선언되기 이전에도 함수를 활용할 수 있기 때문에, 함수 선언문 방식을 따르는 게 좋습니다. 함수 선언 방식은 코드를 유연하게 구성할 수 있도록 해주고, 가독성도 좋습니다.