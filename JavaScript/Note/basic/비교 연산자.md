# 비교 연산자

## 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.

예시:

```jsx
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
```

불린값의 경우 `true`는 `1`, `false`는 `0`으로 변환된 후 비교가 이뤄집니다.

예시:

```jsx
alert( true == 1 ); // true
alert( false == 0 ); // true
```

**흥미로운 상황**

동시에 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있습니다.

- 동등 비교(`==`) 시 true를 반환함
- 논리 평가 시 값 하나는 `true`, 다른 값 하나는 `false`를 반환함

예시:

```jsx
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

두 값(a와 b)을 비교하면 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 참, 하나는 거짓이 반환된다는 점에 고개를 갸우뚱할 수도 있습니다. 그런데 자바스크립트 관점에선 이런 결과가 아주 자연스럽습니다. 동등 비교 연산자 `==`는 (예시에서 문자열 `"0"`을 숫자 `0`으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다.

## 일치 연산자

동등 연산자(equality operator) `==`은 `0`과 `false`를 구별하지 못합니다.

```jsx
alert( 0 == false ); // true
```

피연산자가 빈 문자열일 때도 같은 문제가 발생하죠.

```jsx
alert( '' == false ); // true
```

이런 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생합니다. 빈 문자열과 `false`는 숫자형으로 변환하면 0이 되죠.

그렇다면 `0`과 `false`는 어떻게 구별할 수 있을까요?

**일치 연산자(strict equality operator) `===`를 사용하면 형 변환 없이 값을 비교할 수 있습니다.**

일치 연산자는 엄격한(strict) 동등 연산자입니다. 자료형의 동등 여부까지 검사하기 때문에 피연산자 `a`와 `b`의 형이 다를 경우 `a === b`는 즉시 `false`를 반환합니다.

예시:

```jsx
alert( 0 === false ); // false, 피연산자의 형이 다르기 때문입니다.
```

일치 연산자 `===`가 동등 연산자 `==`의 엄격한 버전인 것처럼 ‘불일치’ 연산자 `!==`는 부등 연산자 `!=`의 엄격한 버전입니다.

일치 연산자는 동등 연산자보다 한 글자 더 길긴 하지만 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여줍니다.

## null이나 undefined와 비교하기

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않은 일들이 발생한다. 일단 몇 가지 규칙을 먼저 살펴본 후, 어떤 예상치 않은 일들이 일어나는지 구체적인 예시를 통해 살펴보도록 하자.

### 일치 연산자`===`를 사용하여 null과 undefined를 비교

두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환된다.

```jsx
alert(null === undefined)l // false
```

### 동등 연산자`==`를 사용하여 null과 undefined를 비교

동등 연산자를 사용해 null과 undefined를 비교하면 특별한 규칙이 적용돼 `ture`가 반환된다. 동등 연산자는 null과 undefined를 ‘각별한 커플’처럼 취급한다. 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못한다.

```jsx
alert( null == undefined ) ; // true
```

### 산술 연산자나 기타 비교 연산자 **`<`, `>`, `<=`, `>=`를 사용하여 `null`과 `undefined`를 비교**

null과 undefined는 숫자형으로 변환된다. null 은 0, undefined는 Nan으로 변한다.

이제 위에서 살펴본 세 가지 규칙들이 어떤 흥미로운 엣지 케이스(edge case)를 만들어내는지 알아보자. 이후, 어떻게 하면 엣지 케이스가 만들어내는 함정에 빠지지 않을 수 있을지에 대해 알아보자.

### null vs 0

```jsx
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위 비교 결과는 논리에 맞지 않아 보인다. (3)에서 null 은 0보다 크거나 같다고 했기 때문에, (1)이나 (2)중 하나는 참이어야 하는데 둘 다 거짓을 반환한다.

이런 결과가 나타나는 이유는 동등 연산자 `==`와 기타 비교 연산자의 동작 방식이 다르기 때문이다. (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0` 이 참을 반환하는 이유는 `null`이 숫자형으로 변환돼 `0`이 되기 때문이다.

그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다. `undefined` 와 `null`을 비교하는 경우에만 true를 반환하고, 그 이외의 경우는 무조건 false를 반환한다. 이런 이유 때문에 (2)는 거짓을 반환하다.

### 비교가 불가능한 undefined

`undefined` 를 다른 값과 비교해서는 안 된다.

```jsx
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

위 예시를 보면 `undefined`는 0을 매우 싫어하는 것처럼 보입니다. 항상 false를 반환하고 있네요.

이런 결과는 아래와 같은 이유 때문에 발생합니다.

- (1)과 (2)에선 `undefined` 가 `NaN`으로 변환되는데 (숫자형으로의 변환), `NaN`이 피연산자인 경우 **비교 연산자는 항상 false를 반환**합니다.
- undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환합니다.

### 함정 피하기

위와 같은 에지 케이스를 왜 살펴보았을까요? 이런 예외적인 경우를 꼭 기억해 놓고 있어야만 할까요? 그렇지는 않습니다. 개발을 하다 보면 자연스레 이런 경우를 만나고 점차 익숙해지기 때문에 지금 당장 암기해야 할 필요는 없습니다. 하지만 아래와 같은 방법을 사용해 이런 예외 상황을 미리 예방할 수 있다는 점은 알아두시길 바랍니다.

- 일치 연산자 `===`를 제외한 비교 연산자의 피연산자에 `undefined`나 `null`이 오지 않도록 특별히 주의하시기 바랍니다.
- 또한, `undefined`나 `null`이 될 가능성이 있는 변수가 `<`, `>`, `<=`, `>=`의 피연산자가 되지 않도록 주의하시기 바랍니다. 명확한 의도를 갖고 있지 않은 이상 말이죠. 만약 변수가 `undefined`나 `null`이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하시기 바랍니다.

# [요약](https://ko.javascript.info/comparison#ref-780)

- 비교 연산자는 불린값을 반환합니다.
- 문자열은 문자 단위로 비교되는데, 이때 비교 기준은 '사전’(유니코드)순입니다.
- 서로 다른 타입의 값을 비교할 땐 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행됩니다(일치 연산자는 제외).
- `null`과 `undefined`는 동등 비교(`==`) 시 서로 같지만 다른 값과는 같지 않습니다.
- `null`이나 `undefined`가 될 확률이 있는 변수가 `>` 또는 `<`의 피연산자로 올 때는 주의를 기울이시기 바랍니다. `null`, `undefined` 여부를 확인하는 코드를 따로 추가하는 습관을 들이길 권유합니다.

문제

```jsx
5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\\n0\\n" → false
null === +"\\n0\\n" → false
```

해설:

1. 명백히 true입니다.
2. 문자열의 비교는 사전순서가 기준이므로 false입니다. `"a"`는 `"p"`보다 작습니다.
3. 두 피연산자는 문자열이므로, 사전순으로 비교가 이뤄집니다. 왼쪽 피연산자의 첫 번째 글자 `"2"`는 오른쪽 피연산자의 첫 번째 글자 `"1"`보다 큽니다.
4. `null`과 `undefined`는 같습니다.
5. 일치 연산자는 형도 체크합니다. 형이 다르면 false가 반환됩니다.
6. (4)와 유사한 문제입니다. `null`은 오직 `undefined`와 같습니다.
7. 형이 다르므로 false가 반환됩니다.