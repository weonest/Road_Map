# 원시값의 메소드

원시값의 종류는

- `문자(string)`, `숫자(number)`, `bigint`, `불린(boolean)`, `심볼(symbol)`, `null`, `undefined`형으로 총 일곱 가지 이다.

객체:

- 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
- `{name : "John", age : 30}`와 같이 대괄호`{}` 를 사용해 만들 수 있다.

객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것이다.

```jsx
let john = {
	name: "John",
	syaHi: function() {
		alert ("친구야 반갑다!"");
	}
};

john.sayHi(); // 친구야 반갑다!
```

하지만, 이런 기능을 사용하다면 시스템 자원이 많이 소모된다는 단점이 있다.

객체는 원시값보다 “무겁고", 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문이다.

## 원시값을 객체처럼 사용하기

1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지한다.
2. 문자열, 숫자, 불린, 심볼의 메소드와 프로퍼티에 접근할 수 있도록 언어 차원에서 허용한다.
3. 이를 가능하게 하기 위해, 원시값이 메소드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, “원시 래퍼 객체(object wrapper)”를 만들어 준다. 이 객체는 곧 삭제 된다.

아래 예시를 보자

### str.toUpperCase()

```jsx
let str = "Hello";
alert(str.toUpperCase()); // HELLO
```

위 함수의 내부에서 실제로 일어나는 일은 다음과 같다.

1. 문자열 `str`은 원시값이므로 원시값의 프로퍼티에 접근하는 순간 특별한 객체가 만들어진다. 이 객체는 문자열의 값을 알고 있고, `toUpperCase()`와 같은 유용한 메소드를 가지고 있다.
2. 메소드가 실행되고, 새로운 문자열이 반환된다.
3. 특별한 객체는 파괴되고, 원시값 `str`만 남는다.

이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메소드를 호출할 수 있는 것이다.

> **`String/Number/Boolean`를 생성자론 쓰지 맙시다.**
>
> 이런 식으로 래퍼 객체를 만드는 건 추천하지 않는다. 몇몇 상황에서 혼동을 불러일으키기 때문이다.
>
> ```jsx
> alert (typeof 0 ); // "number"
> 
> alert (typeof new Number(0)); // "object"!
> ```
>
> 객체는 논리 평가 시 항상 **“참"**을 반환하기 때문이다. (조건식으로 사용시 참과 거짓을 구분하지 못하게 되기 때문에 사용 자제!)

## 요약

- 'null’과 'undefined’를 제외한 원시값에 다양한 메서드를 호출할 수 있습니다. 이에 대해선 별도의 챕터에서 곧 알아보도록 하겠습니다.
- 원시값에 메서드를 호출하려 하면 임시 객체가 만들어집니다. 그런데 자바스크립트 엔진은 내부 최적화가 잘 되어있어 메서드를 호출해도 많은 리소스를 쓰지 않습니다.