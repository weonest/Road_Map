# Chrome으로 디버깅

디버깅`debugging`은 스크립트 내 에러를 검출해 제거하는 일련의 과정.

- 모던 브라우저와 호스트 환경 대부분은 개발자 도구 안에 UI 형태로 디버깅 툴을 구비해 놓는다.
- 디버깅 툴을 사용하면 디버깅이 훨씬 쉬워지고, 실행 단계마다 어떤 일이 일어나는지를 코드 단위로 추적 가능.

## ‘Sources’ 패널

f12 혹은 페이지 검사 버튼을 눌러 개발자 툴을 연다.

ESC 를 누르면 Console 패널을 열 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b605e90-d247-4b19-ad5e-fcf1e1a40d3c/Untitled.png)

1. 파일 탐색 영역 - 페이지를 구성하는 데 쓰인 모든 리소스 (HTML. JavaScript, CSS, 이미지 파일 등)를 트리 형태로 보여준다.
2. 코드 에디터 영역 - 리소스 영역에서 선택한 파일의 소스 코드를 보여준다. **여기서 소스코드를 편집할 수도 있다.**
3. 자바스크립트 디버깅 영역 - 디버깅에 관련된 기능을 제공

## 중단점

내부에서 무슨 일이 일어나는지 자세히 살펴보자.

좌측의 줄 번호를 클릭하면 중단점을 설정할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/54d7b464-5db1-47c9-8730-9399f5bf2785/Untitled.png)

중단점 (breakpoint)는 말 그대로 실행이 중단되는 코드 내 지점이다.

중단점을 이용하면 실행이 중지된 시점에서 변수가 어떤 값을 담고 있는지 알 수 있다. 또한, 실행이 중지된 시점을 기준으로 명령어를 실행할 수도 있다. = 디버깅이 가능해지는 것.

Sources 패널 우측의 디버깅 영역을 보면 중단점 목록을 확인할 수 있다. 파일 여러 개에 다수의 중단점을 설정해 놓은 경우, 디버깅 영역을 이용하면 아래와 같은 작업을 할 수도 있다.

- 항목을 클릭해 해당 중단점이 설정된 곳으로 바로 이동.
- 체크 박스 선택을 해제해 해당 중단점을 비활성화 할 수 있다.
- 마우스 오른쪽 버튼을 클릭했을 때 나오는 ‘Remove breakpoint’옵션을 통해 중단점을 삭제할 수 있다.

> **조건부 중단점**
>
> 줄 번호에 커서를 옮긴 후 마우스 오른쪽 버튼을 클릭하면 조건부 중단점(conditional breakpoint)을 설정할 수 있다. 표현식이 참인 경우에만 실행을 중지시킬 수 있다.
>
> 조건부 중단점을 설정하면 변수에 특정 값이 할당될 때나 함수의 매개 변수에 특정 값이 들어올 때만 실행을 중단시킬 수 있어 디버깅 시 유용하게 활용할 수 있다.

## debugger 명령어

```jsx
function hello(name) {
  let phrase = `Hello, ${name}!`;

  **debugger;  // <-- 여기서 실행이 멈춥니다.**

  say(phrase);
}
```

- 중단점을 설정한 것과 같은 효과를 본다.

## 멈추면 보이는 것들

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e8c0f5b-0b9c-469e-80f0-ba98dd2dd1b6/Untitled.png)

중단점 설정후 새로 고침을 통해 중단점을 작동시켜보자.

이 상태에서 디버깅 영역의 하위 패널들은 다음과 같은 기능을 제공한다.

1. Watch - 표현식을 평가하고 결과를 보여준다.

   add Expression 버튼 `+` 를 클릭해 원하는 표현식을 입력한 후 Enter 를 누르면 중단 시점의 값을 보여준다. 입력한 표현식은 실행 과정 중에 계속해서 재평가 된다.

2. **Call Stack** - 코드를 해당 중단점으로 안내한 실행 경로를 역순으로 표시한다.

   실행은 `index.html` 안에서 `hello()`를 호출하는 과정 중에 멈췄다. 함수 `hello` 내에 중단점을 설정했기 때문에, 콜 스택 최상단에 `hello` 가 위치한다. `index.html`에서 함수 `hello`를 정의하지 않았기 때문에 콜 스택 하단에 ‘anonymous’가 출력된다.

3. Scope - 현재 정의된 모든 변수를 출력한다.

   `Local`은 함수의 지역변수를 보여준다. 지역 변수 정보는 소스 코드 영역에서도 확인(강조 푯)할 수 있다.

   `Global`은 함수 바깥에 정의된 전역 변수를 보여준다.

   `Local` 하위 항목으로 `this`에 대한 정보도 출력된다.

## 실행 추적하기

**– ‘Resume’: 스크립트 실행을 다시 시작함 (단축키 F8)**

실행을 재개한다. 추가 중단점이 없는 경우, 실행이 쭉 이어지고 디버거는 동작하지 않는다.

**– ‘Step’: 다음 명령어를 실행함 (단축키 F9)**

다음 문을 실행한다. Step 버튼을 계속 누르면 스크립트 전체를 문 단위로 하나하나 실행할 수 있다.

**– ‘Step over’: 다음 명령어를 실행하되, \*함수 안으로 들어가진 않음\* (단축키 F10)**

‘Step’과 유사하지만, 다음 문이 함수 호출일 때 ‘Step’과는 다르게 동작. (`alert` 가튼 내장함수에 해당하지 않고, 직접 작성한 함수일 때만 동작이 다름.)

‘Step’은 함수 내부로 들어가 함수 본문 첫 번째 줄에서 실행을 멈춘다. 반면 ‘Step over’는 보이지 않는 곳에서 중첩 함수를 실행하긴 하지만 함수 내로 진입하지 않는다.

실행은 함수 실행이 끝난 후에 즉시 멈춘다.

‘Step over’는 함수 호출 시 내부에서 어떤 일이 일어나는지 **궁금하지 않을 때 유용.**

**– ‘Step into’ (단축키 F11)**

‘Step’과 유사한데, 비동기 함수 호출에서 ‘Step’과는 다르게 동작한다.

‘Step’은 `setTimeout`(함수 호출 스케줄링에 쓰이는 내장 메소드)같은 비동기 동작은 무시한다. 반면 ‘Step into’는 비동기 동작을 담당하는 코드로 진입하고, 필요하다면 비동기 동작이 완료될 때까지 대기한다.

**– ‘Step out’: 실행 중인 함수의 실행이 끝날 때 까지 실행을 계속함 (단축키 Shift+F11)**

현재 실행 중인 함수의 실행을 계속 이어가다가 함수 본문 마지막 줄에서 실행을 멈춘다. 실수로 `Step`을 눌러 **내부 동작을 알고 싶지 않은 중첩 함수로 진입했거나 가능한 한 빨리 함수 실행을 끝내고 싶은 경우 유용.**

## console.log

```jsx
// 콘솔창을 열어 결과를 확인해 보세요.
for (let i = 0; i < 5; i++) {
  console.log("숫자", i);
}
```

결과는 콘솔창에만 있기 때문에 일반 사용자는 결과를 볼 수 없다.

- 결과를 보려면 개발자 도구의 콘솔 패널을 직접 열어야 한다.
- 코드에 `console.log`를 적절히 넣어주었다면 디버거 없이도 무슨 일이 일어나고 있는지 충분히 파악할 수 있으므로 적절히 활용하면 좋다.

## 요약

스크립트 실행이 중단되는 경우는 다음과 같습니다.

1. 중단점을 만났을 때
2. `debugger`문 만났을 때
3. 에러가 발생했을 때

스크립트 실행이 중지되면 중단 시점을 기준으로 변수에 어떤 값이 들어가 있는지 확인할 수 있습니다. 또한 단계별로 코드를 실행해 가며, 어디서 문제가 발생했는지 추적할 수도 있습니다. 이런 식으로 디버깅이 진행됩니다.